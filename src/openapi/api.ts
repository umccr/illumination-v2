/* tslint:disable */
/* eslint-disable */
/**
 * ICA Rest API
 * This API can be used to interact with Illumina Connected Analytics.<br> <p> Authentication to the  API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <b>API-key</b><br> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <b>JWT</b><br> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint  using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br> </p> <p> <b>Basic Authentication</b><br> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use \"Basic base64encoded(emailaddress:password)\" in the \"Authorization\" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the \"tenant\" request parameter to indicate what tenant you would like to request a JWT for. </p> 
 *
 * The version of the OpenAPI document: 3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AWSDetails
 */
export interface AWSDetails {
    /**
     * The name of the s3 bucket
     * @type {string}
     * @memberof AWSDetails
     */
    'bucketName': string;
    /**
     * Key prefix within the bucket for ICA to operate within. Data may only be created having this prefix and the given credentials will only give access to it. If not set, default is to allow operation on the full bucket. No leading slash, and must end with a trailing slash.
     * @type {string}
     * @memberof AWSDetails
     */
    'keyPrefix'?: string | null;
    /**
     * Used to specify the type of server-side encryption (SSE) to be used on the object provider. This value is used to determine the Amazon S3 header \"x-amz-server-side-encryption\" value. For example, specify \"AES256\" for SSE-S3, or \"AWS:KMS\" for SSE-KMS. By default if none is specified, \"AES256\" will be used.
     * @type {string}
     * @memberof AWSDetails
     */
    'serverSideEncryptionAlgorithm'?: string | null;
    /**
     * Used to specify the server-side encryption key that might be associated with the specified server-side encryption algorithm. This value can be the AWS KMS arn key, to be used for the Amazon S3 header \"x-amz-server-side-encryption-aws-kms-key-id\" value. Value will be ignored if encryption is \"AES256\".
     * @type {string}
     * @memberof AWSDetails
     */
    'serverSideEncryptionKey'?: string | null;
}
/**
 * 
 * @export
 * @interface ActivationCodeDetail
 */
export interface ActivationCodeDetail {
    /**
     * 
     * @type {string}
     * @memberof ActivationCodeDetail
     */
    'id': string;
    /**
     * The allowed slot within this code, empty means unlimited
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'allowedSlots'?: number | null;
    /**
     * Indicates how many slots can are used.
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'usedSlots'?: number | null;
    /**
     * The slots that where moved to another activation code
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'movedSlots'?: number | null;
    /**
     * The assigned allowed slot within this code, empty means unlimited
     * @type {number}
     * @memberof ActivationCodeDetail
     */
    'originalSlots'?: number | null;
    /**
     * 
     * @type {PipelineBundle}
     * @memberof ActivationCodeDetail
     */
    'pipelineBundle': PipelineBundle;
    /**
     * 
     * @type {Array<ActivationCodeDetailUsage>}
     * @memberof ActivationCodeDetail
     */
    'usages': Array<ActivationCodeDetailUsage>;
}
/**
 * 
 * @export
 * @interface ActivationCodeDetailList
 */
export interface ActivationCodeDetailList {
    /**
     * 
     * @type {Array<ActivationCodeDetail>}
     * @memberof ActivationCodeDetailList
     */
    'items': Array<ActivationCodeDetail>;
}
/**
 * 
 * @export
 * @interface ActivationCodeDetailUsage
 */
export interface ActivationCodeDetailUsage {
    /**
     * 
     * @type {Project}
     * @memberof ActivationCodeDetailUsage
     */
    'project'?: Project;
    /**
     * Indicates how many slots can are used
     * @type {number}
     * @memberof ActivationCodeDetailUsage
     */
    'usedSlots'?: number | null;
    /**
     * Indicates how many slots can be used
     * @type {number}
     * @memberof ActivationCodeDetailUsage
     */
    'allowedSlots'?: number | null;
}
/**
 * 
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    'tenantName'?: string | null;
    /**
     * The unique reference of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'reference': string;
    /**
     * The user reference of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'userReference': string;
    /**
     * 
     * @type {Pipeline}
     * @memberof Analysis
     */
    'pipeline': Pipeline;
    /**
     * The status of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'status': AnalysisStatusEnum;
    /**
     * When the analysis was started
     * @type {string}
     * @memberof Analysis
     */
    'startDate'?: string | null;
    /**
     * When the analysis was finished
     * @type {string}
     * @memberof Analysis
     */
    'endDate'?: string | null;
    /**
     * The summary of the analysis
     * @type {string}
     * @memberof Analysis
     */
    'summary'?: string | null;
    /**
     * 
     * @type {AnalysisStorage}
     * @memberof Analysis
     */
    'analysisStorage'?: AnalysisStorage;
    /**
     * 
     * @type {AnalysisTag}
     * @memberof Analysis
     */
    'tags': AnalysisTag;
}

export const AnalysisStatusEnum = {
    Requested: 'REQUESTED',
    Awaitinginput: 'AWAITINGINPUT',
    Inprogress: 'INPROGRESS',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Failedfinal: 'FAILEDFINAL',
    Aborted: 'ABORTED'
} as const;

export type AnalysisStatusEnum = typeof AnalysisStatusEnum[keyof typeof AnalysisStatusEnum];

/**
 * 
 * @export
 * @interface AnalysisData
 */
export interface AnalysisData {
    /**
     * The id of the file/folder.
     * @type {string}
     * @memberof AnalysisData
     */
    'dataId': string;
    /**
     * 
     * @type {DataFormat}
     * @memberof AnalysisData
     */
    'format': DataFormat | null;
    /**
     * The name of the file/folder as it was processed by the analysis.
     * @type {string}
     * @memberof AnalysisData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisData
     */
    'dataType': AnalysisDataDataTypeEnum;
}

export const AnalysisDataDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
} as const;

export type AnalysisDataDataTypeEnum = typeof AnalysisDataDataTypeEnum[keyof typeof AnalysisDataDataTypeEnum];

/**
 * 
 * @export
 * @interface AnalysisDataInput
 */
export interface AnalysisDataInput {
    /**
     * 
     * @type {string}
     * @memberof AnalysisDataInput
     */
    'parameterCode': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnalysisDataInput
     */
    'dataIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface AnalysisInput
 */
export interface AnalysisInput {
    /**
     * The name of the input-parameter.
     * @type {string}
     * @memberof AnalysisInput
     */
    'code': string;
    /**
     * The analysis-data used as input by the analysis.
     * @type {Array<AnalysisData>}
     * @memberof AnalysisInput
     */
    'analysisData'?: Array<AnalysisData> | null;
}
/**
 * 
 * @export
 * @interface AnalysisInputList
 */
export interface AnalysisInputList {
    /**
     * 
     * @type {Array<AnalysisInput>}
     * @memberof AnalysisInputList
     */
    'items': Array<AnalysisInput>;
}
/**
 * 
 * @export
 * @interface AnalysisOutput
 */
export interface AnalysisOutput {
    /**
     * The name of the output-parameter.
     * @type {string}
     * @memberof AnalysisOutput
     */
    'code': string;
    /**
     * 
     * @type {Array<AnalysisData>}
     * @memberof AnalysisOutput
     */
    'data'?: Array<AnalysisData>;
}
/**
 * 
 * @export
 * @interface AnalysisOutputList
 */
export interface AnalysisOutputList {
    /**
     * 
     * @type {Array<AnalysisOutput>}
     * @memberof AnalysisOutputList
     */
    'items': Array<AnalysisOutput>;
}
/**
 * 
 * @export
 * @interface AnalysisPagedList
 */
export interface AnalysisPagedList {
    /**
     * 
     * @type {Array<Analysis>}
     * @memberof AnalysisPagedList
     */
    'items': Array<Analysis>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof AnalysisPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof AnalysisPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof AnalysisPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface AnalysisParameter
 */
export interface AnalysisParameter {
    /**
     * 
     * @type {string}
     * @memberof AnalysisParameter
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisParameter
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisRawOutput
 */
export interface AnalysisRawOutput {
    /**
     * The raw output of the analysis.
     * @type {string}
     * @memberof AnalysisRawOutput
     */
    'rawOutput': string;
}
/**
 * 
 * @export
 * @interface AnalysisReferenceDataParameter
 */
export interface AnalysisReferenceDataParameter {
    /**
     * 
     * @type {string}
     * @memberof AnalysisReferenceDataParameter
     */
    'parameterCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisReferenceDataParameter
     */
    'referenceDataId'?: string;
}
/**
 * 
 * @export
 * @interface AnalysisStep
 */
export interface AnalysisStep {
    /**
     * 
     * @type {string}
     * @memberof AnalysisStep
     */
    'id': string;
    /**
     * The status of the analysis step
     * @type {string}
     * @memberof AnalysisStep
     */
    'status': AnalysisStepStatusEnum;
    /**
     * When the analysis step was queued
     * @type {string}
     * @memberof AnalysisStep
     */
    'queueDate'?: string | null;
    /**
     * When the analysis step was started
     * @type {string}
     * @memberof AnalysisStep
     */
    'startDate'?: string | null;
    /**
     * When the analysis step was finished
     * @type {string}
     * @memberof AnalysisStep
     */
    'endDate'?: string | null;
    /**
     * Indicates which kind of step was executed
     * @type {boolean}
     * @memberof AnalysisStep
     */
    'technical': boolean;
}

export const AnalysisStepStatusEnum = {
    Failed: 'FAILED',
    Done: 'DONE',
    Running: 'RUNNING',
    Interrupted: 'INTERRUPTED',
    Aborted: 'ABORTED',
    Waiting: 'WAITING'
} as const;

export type AnalysisStepStatusEnum = typeof AnalysisStepStatusEnum[keyof typeof AnalysisStepStatusEnum];

/**
 * 
 * @export
 * @interface AnalysisStepList
 */
export interface AnalysisStepList {
    /**
     * 
     * @type {Array<AnalysisStep>}
     * @memberof AnalysisStepList
     */
    'items': Array<AnalysisStep>;
}
/**
 * 
 * @export
 * @interface AnalysisStorage
 */
export interface AnalysisStorage {
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof AnalysisStorage
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage option
     * @type {string}
     * @memberof AnalysisStorage
     */
    'name': string;
    /**
     * The description about the storage option
     * @type {string}
     * @memberof AnalysisStorage
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface AnalysisStorageList
 */
export interface AnalysisStorageList {
    /**
     * 
     * @type {Array<AnalysisStorage>}
     * @memberof AnalysisStorageList
     */
    'items': Array<AnalysisStorage>;
}
/**
 * 
 * @export
 * @interface AnalysisTag
 */
export interface AnalysisTag {
    /**
     * Technical tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'technicalTags': Array<string>;
    /**
     * User tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'userTags': Array<string>;
    /**
     * Reference tags
     * @type {Array<string>}
     * @memberof AnalysisTag
     */
    'referenceTags': Array<string>;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * The unique name identifying the application
     * @type {string}
     * @memberof Application
     */
    'name': string;
    /**
     * The type of the application
     * @type {string}
     * @memberof Application
     */
    'type': ApplicationTypeEnum;
    /**
     * The display name of the application
     * @type {string}
     * @memberof Application
     */
    'displayName'?: string | null;
}

export const ApplicationTypeEnum = {
    Main: 'MAIN',
    Websolution: 'WEBSOLUTION',
    External: 'EXTERNAL'
} as const;

export type ApplicationTypeEnum = typeof ApplicationTypeEnum[keyof typeof ApplicationTypeEnum];

/**
 * The credentials that are required when the type of the Storage Credential being updated is AWS
 * @export
 * @interface AwsCredentials
 */
export interface AwsCredentials {
    /**
     * The access key found in aws console
     * @type {string}
     * @memberof AwsCredentials
     */
    'accessKeyId': string;
    /**
     * The secret access key found in aws console
     * @type {string}
     * @memberof AwsCredentials
     */
    'secretAccessKey': string;
}
/**
 * In case of AWS S3 stored data, this will contain the credentials for uploading or downloading the data.
 * @export
 * @interface AwsTempCredentials
 */
export interface AwsTempCredentials {
    /**
     * The S3 access key.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'accessKey': string;
    /**
     * The S3 secret key.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'secretKey': string;
    /**
     * The S3 session token.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'sessionToken': string;
    /**
     * The S3 region.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'region': string;
    /**
     * The S3 bucket name.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'bucket': string;
    /**
     * The S3 object prefix these temporary credentials will give access to.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'objectPrefix': string;
    /**
     * Used to specify the type of server-side encryption (SSE) to be used on the object provider. This value is used to determine the Amazon S3 header \"x-amz-server-side-encryption\" value. For example, specify \"AES256\" for SSE-S3, or \"AWS:KMS\" for SSE-KMS. By default if none is specified, \"AES256\" will be used.
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'serverSideEncryptionAlgorithm'?: string | null;
    /**
     * Used to specify the server-side encryption key that might be associated with the specified server-side encryption algorithm. This value can be the AWS KMS arn key, to be used for the Amazon S3 header \"x-amz-server-side-encryption-aws-kms-key-id\" value. Value will be ignored if encryption is \"AES256\"
     * @type {string}
     * @memberof AwsTempCredentials
     */
    'serverSideEncryptionKey'?: string | null;
}
/**
 * 
 * @export
 * @interface BaseConnection
 */
export interface BaseConnection {
    /**
     * Specifies the supported snowflake authenticator to use. Currently \'oauth\' only is supported
     * @type {string}
     * @memberof BaseConnection
     */
    'authenticator': string;
    /**
     * Specifies the OAuth token to use for authentication
     * @type {string}
     * @memberof BaseConnection
     */
    'accessToken': string;
    /**
     * snowflake dns name. Usually something like \'<<account>>.snowflakecomputing.com\'
     * @type {string}
     * @memberof BaseConnection
     */
    'dnsName': string;
    /**
     * Specifies the user principal name. This is required for some snowflake client (snowSQL for instance)
     * @type {string}
     * @memberof BaseConnection
     */
    'userPrincipalName': string;
    /**
     * Specifies the database name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'databaseName': string;
    /**
     * Specifies the schema name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'schemaName': string;
    /**
     * Specifies the warehouse name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'warehouseName': string;
    /**
     * Specifies the role name bound to the project specified
     * @type {string}
     * @memberof BaseConnection
     */
    'roleName': string;
}
/**
 * 
 * @export
 * @interface BaseJob
 */
export interface BaseJob {
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof BaseJob
     */
    'tenantName'?: string | null;
    /**
     * A short description of the base job
     * @type {string}
     * @memberof BaseJob
     */
    'description'?: string | null;
    /**
     * 
     * @type {ProjectBaseTable}
     * @memberof BaseJob
     */
    'table'?: ProjectBaseTable | null;
    /**
     * The type of the job
     * @type {string}
     * @memberof BaseJob
     */
    'type': BaseJobTypeEnum;
    /**
     * The status of the job
     * @type {string}
     * @memberof BaseJob
     */
    'status': BaseJobStatusEnum;
    /**
     * The duration of the job expressed in milliseconds
     * @type {number}
     * @memberof BaseJob
     */
    'overallDuration'?: number | null;
    /**
     * Detailed description of the job
     * @type {string}
     * @memberof BaseJob
     */
    'details'?: string | null;
    /**
     * Bytes billed
     * @type {number}
     * @memberof BaseJob
     */
    'bytesBilled'?: number | null;
}

export const BaseJobTypeEnum = {
    Copytable: 'COPYTABLE',
    Exporttable: 'EXPORTTABLE',
    Createtable: 'CREATETABLE',
    Executequery: 'EXECUTEQUERY',
    Loaddata: 'LOADDATA',
    Preparedata: 'PREPAREDATA'
} as const;

export type BaseJobTypeEnum = typeof BaseJobTypeEnum[keyof typeof BaseJobTypeEnum];
export const BaseJobStatusEnum = {
    Created: 'CREATED',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Pending: 'PENDING',
    Inprogress: 'INPROGRESS',
    Aborted: 'ABORTED'
} as const;

export type BaseJobStatusEnum = typeof BaseJobStatusEnum[keyof typeof BaseJobStatusEnum];

/**
 * 
 * @export
 * @interface BaseJobList
 */
export interface BaseJobList {
    /**
     * 
     * @type {Array<BaseJob>}
     * @memberof BaseJobList
     */
    'items': Array<BaseJob>;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'shortDescription'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof Bundle
     */
    'region': Region;
    /**
     * 
     * @type {MetadataModel}
     * @memberof Bundle
     */
    'metadataModel'?: MetadataModel | null;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'releaseVersion': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'versionComment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'status': BundleStatusEnum;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof Bundle
     */
    'categories'?: Array<string> | null;
    /**
     * 
     * @type {Links}
     * @memberof Bundle
     */
    'links'?: Links | null;
}

export const BundleStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED'
} as const;

export type BundleStatusEnum = typeof BundleStatusEnum[keyof typeof BundleStatusEnum];

/**
 * 
 * @export
 * @interface BundleData
 */
export interface BundleData {
    /**
     * 
     * @type {Data}
     * @memberof BundleData
     */
    'data': Data;
    /**
     * 
     * @type {string}
     * @memberof BundleData
     */
    'bundleId': string;
}
/**
 * 
 * @export
 * @interface BundleDataPagedList
 */
export interface BundleDataPagedList {
    /**
     * 
     * @type {Array<BundleData>}
     * @memberof BundleDataPagedList
     */
    'items': Array<BundleData>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundleDataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundleDataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundleDataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface BundleList
 */
export interface BundleList {
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof BundleList
     */
    'items': Array<Bundle>;
}
/**
 * 
 * @export
 * @interface BundlePagedList
 */
export interface BundlePagedList {
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof BundlePagedList
     */
    'items': Array<Bundle>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundlePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundlePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundlePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface BundlePipeline
 */
export interface BundlePipeline {
    /**
     * 
     * @type {Pipeline}
     * @memberof BundlePipeline
     */
    'pipeline': Pipeline;
    /**
     * 
     * @type {string}
     * @memberof BundlePipeline
     */
    'bundleId': string;
}
/**
 * 
 * @export
 * @interface BundlePipelineList
 */
export interface BundlePipelineList {
    /**
     * 
     * @type {Array<BundlePipeline>}
     * @memberof BundlePipelineList
     */
    'items': Array<BundlePipeline>;
}
/**
 * 
 * @export
 * @interface BundleSample
 */
export interface BundleSample {
    /**
     * 
     * @type {Sample}
     * @memberof BundleSample
     */
    'sample': Sample;
    /**
     * 
     * @type {string}
     * @memberof BundleSample
     */
    'bundleId': string;
}
/**
 * 
 * @export
 * @interface BundleSamplePagedList
 */
export interface BundleSamplePagedList {
    /**
     * 
     * @type {Array<BundleSample>}
     * @memberof BundleSamplePagedList
     */
    'items': Array<BundleSample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof BundleSamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof BundleSamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof BundleSamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface BundleTool
 */
export interface BundleTool {
    /**
     * 
     * @type {CWLToolDefinition}
     * @memberof BundleTool
     */
    'cwlToolDefinition': CWLToolDefinition;
}
/**
 * 
 * @export
 * @interface BundleToolsList
 */
export interface BundleToolsList {
    /**
     * 
     * @type {Array<BundleTool>}
     * @memberof BundleToolsList
     */
    'items': Array<BundleTool>;
}
/**
 * 
 * @export
 * @interface CWLToolDefinition
 */
export interface CWLToolDefinition {
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'tenantName'?: string | null;
    /**
     * Name of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'name': string;
    /**
     * Description of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'description'?: string | null;
    /**
     * Status of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'status': CWLToolDefinitionStatusEnum;
    /**
     * version comment of the tool definition
     * @type {string}
     * @memberof CWLToolDefinition
     */
    'versionComment'?: string | null;
    /**
     * release version of the tool definition
     * @type {number}
     * @memberof CWLToolDefinition
     */
    'releaseVersion'?: number | null;
    /**
     * 
     * @type {Link}
     * @memberof CWLToolDefinition
     */
    'links'?: Link;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof CWLToolDefinition
     */
    'categories'?: Array<string> | null;
}

export const CWLToolDefinitionStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED',
    Releasecandidate: 'RELEASECANDIDATE',
    Building: 'BUILDING',
    Buildfailed: 'BUILDFAILED'
} as const;

export type CWLToolDefinitionStatusEnum = typeof CWLToolDefinitionStatusEnum[keyof typeof CWLToolDefinitionStatusEnum];

/**
 * 
 * @export
 * @interface CompleteFolderUploadSession
 */
export interface CompleteFolderUploadSession {
    /**
     * The number of expected uploaded files within this session.
     * @type {number}
     * @memberof CompleteFolderUploadSession
     */
    'numberOfExpectedUploadedFiles': number;
}
/**
 * 
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof Connector
     */
    'active': boolean;
    /**
     * Indicates if the connector is connected or not. This is cached so even when the connector is no longer connected, for a short time this still may return true.
     * @type {boolean}
     * @memberof Connector
     */
    'connected': boolean;
    /**
     * Technical code to be used for processing.
     * @type {string}
     * @memberof Connector
     */
    'technicalCode': string;
    /**
     * The key provided via other channels to initialize the installation.
     * @type {string}
     * @memberof Connector
     */
    'initializationKey'?: string | null;
    /**
     * 
     * @type {Country}
     * @memberof Connector
     */
    'country'?: Country | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'addressLine1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'addressLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'addressLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'postalCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'state'?: string | null;
    /**
     * The general description of the connector instance including its purpose.
     * @type {string}
     * @memberof Connector
     */
    'description'?: string | null;
    /**
     * The mode the connector runs in.
     * @type {string}
     * @memberof Connector
     */
    'mode': ConnectorModeEnum;
    /**
     * The maximum bandwidth defined in MB per second.
     * @type {number}
     * @memberof Connector
     */
    'maxBandwidth'?: number | null;
    /**
     * The maximum amount of concurrent transfers that this connector can execute.
     * @type {number}
     * @memberof Connector
     */
    'maxConcurrentTransfers'?: number | null;
    /**
     * The target OS of the original connector installer.
     * @type {string}
     * @memberof Connector
     */
    'os': ConnectorOsEnum;
    /**
     * 
     * @type {string}
     * @memberof Connector
     */
    'installationStatus': ConnectorInstallationStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Connector
     */
    'newConnectorVersionAvailable': boolean;
}

export const ConnectorModeEnum = {
    Download: 'DOWNLOAD',
    Upload: 'UPLOAD',
    Both: 'BOTH',
    None: 'NONE'
} as const;

export type ConnectorModeEnum = typeof ConnectorModeEnum[keyof typeof ConnectorModeEnum];
export const ConnectorOsEnum = {
    Windows: 'WINDOWS',
    Linux: 'LINUX',
    Osx: 'OSX'
} as const;

export type ConnectorOsEnum = typeof ConnectorOsEnum[keyof typeof ConnectorOsEnum];
export const ConnectorInstallationStatusEnum = {
    PendingInstallation: 'PENDING_INSTALLATION',
    Installed: 'INSTALLED',
    Error: 'ERROR',
    Unknown: 'UNKNOWN',
    Cancelled: 'CANCELLED'
} as const;

export type ConnectorInstallationStatusEnum = typeof ConnectorInstallationStatusEnum[keyof typeof ConnectorInstallationStatusEnum];

/**
 * 
 * @export
 * @interface ConnectorList
 */
export interface ConnectorList {
    /**
     * 
     * @type {Array<Connector>}
     * @memberof ConnectorList
     */
    'items': Array<Connector>;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'tenantName'?: string | null;
    /**
     * The country code as defined by ISO.
     * @type {string}
     * @memberof Country
     */
    'code': string;
    /**
     * The full name of the country.
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * The region where the country belong to.
     * @type {string}
     * @memberof Country
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface CreateBundle
 */
export interface CreateBundle {
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'shortDescription'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleReleaseVersion': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleVersionComment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'regionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'metadataModelId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBundle
     */
    'bundleStatus': CreateBundleBundleStatusEnum;
    /**
     * category tags as string array
     * @type {Array<string>}
     * @memberof CreateBundle
     */
    'categories': Array<string>;
    /**
     * 
     * @type {Links}
     * @memberof CreateBundle
     */
    'links'?: Links | null;
}

export const CreateBundleBundleStatusEnum = {
    Draft: 'DRAFT',
    Released: 'RELEASED',
    Deprecated: 'DEPRECATED'
} as const;

export type CreateBundleBundleStatusEnum = typeof CreateBundleBundleStatusEnum[keyof typeof CreateBundleBundleStatusEnum];

/**
 * 
 * @export
 * @interface CreateConnector
 */
export interface CreateConnector {
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateConnector
     */
    'active': boolean;
    /**
     * ID of the country. If not provided then the country of the tenant will be used.
     * @type {string}
     * @memberof CreateConnector
     */
    'countryId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'addressLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'postalCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateConnector
     */
    'state'?: string | null;
    /**
     * The general description of the connector instance including its purpose.
     * @type {string}
     * @memberof CreateConnector
     */
    'description'?: string | null;
    /**
     * The mode the connector runs in.
     * @type {string}
     * @memberof CreateConnector
     */
    'mode': CreateConnectorModeEnum;
    /**
     * The maximum bandwidth defined in MB per second.
     * @type {number}
     * @memberof CreateConnector
     */
    'maxBandwidth'?: number | null;
    /**
     * The maximum amount of concurrent transfers that this connector can execute.
     * @type {number}
     * @memberof CreateConnector
     */
    'maxConcurrentTransfers'?: number | null;
    /**
     * The target OS of the original connector installer.
     * @type {string}
     * @memberof CreateConnector
     */
    'os': CreateConnectorOsEnum;
}

export const CreateConnectorModeEnum = {
    Download: 'DOWNLOAD',
    Upload: 'UPLOAD',
    Both: 'BOTH',
    None: 'NONE'
} as const;

export type CreateConnectorModeEnum = typeof CreateConnectorModeEnum[keyof typeof CreateConnectorModeEnum];
export const CreateConnectorOsEnum = {
    Windows: 'WINDOWS',
    Linux: 'LINUX',
    Osx: 'OSX'
} as const;

export type CreateConnectorOsEnum = typeof CreateConnectorOsEnum[keyof typeof CreateConnectorOsEnum];

/**
 * 
 * @export
 * @interface CreateCustomEvent
 */
export interface CreateCustomEvent {
    /**
     * The event code that should match a custom subscription.
     * @type {string}
     * @memberof CreateCustomEvent
     */
    'code': string;
    /**
     * The content that will be forwarded to the configured custom subscription destinations.
     * @type {object}
     * @memberof CreateCustomEvent
     */
    'content': object;
}
/**
 * 
 * @export
 * @interface CreateCustomNotificationSubscription
 */
export interface CreateCustomNotificationSubscription {
    /**
     * The custom event code to subscribe to
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'customEventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CreateCustomNotificationSubscription
     */
    'enabled': boolean;
    /**
     * The id of the notification channel used to send on
     * @type {string}
     * @memberof CreateCustomNotificationSubscription
     */
    'notificationChannelId': string;
}
/**
 * 
 * @export
 * @interface CreateCwlAnalysis
 */
export interface CreateCwlAnalysis {
    /**
     * The user-reference of the analysis. This should be something meaningful for the user.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'userReference': string;
    /**
     * The pipeline for which an analysis will be created.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'pipelineId': string;
    /**
     * 
     * @type {AnalysisTag}
     * @memberof CreateCwlAnalysis
     */
    'tags': AnalysisTag;
    /**
     * Indicates under which activation code the pipeline is executed.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'activationCodeDetailId': string;
    /**
     * The id of the storage to use for the analysis.
     * @type {string}
     * @memberof CreateCwlAnalysis
     */
    'analysisStorageId'?: string | null;
    /**
     * 
     * @type {CwlAnalysisInput}
     * @memberof CreateCwlAnalysis
     */
    'analysisInput': CwlAnalysisInput;
}
/**
 * 
 * @export
 * @interface CreateData
 */
export interface CreateData {
    /**
     * The name of the file/folder as how it will be created.
     * @type {string}
     * @memberof CreateData
     */
    'name': string;
    /**
     * The id of the folder you want to create this new data in. Alternatively, the folderPath attribute could be used as well for this.
     * @type {string}
     * @memberof CreateData
     */
    'folderId'?: string | null;
    /**
     * The absolute path of the folder you want to create this new data in. Alternatively, the folderId attribute could be used as well for this. In case the folder path does not yet exist, it will be automatically created.
     * @type {string}
     * @memberof CreateData
     */
    'folderPath'?: string | null;
    /**
     * The code of the format you would like to assign at creation time. This is only allowed for file data. If not specified, auto format assignment will be done.
     * @type {string}
     * @memberof CreateData
     */
    'formatCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateData
     */
    'dataType': CreateDataDataTypeEnum;
}

export const CreateDataDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
} as const;

export type CreateDataDataTypeEnum = typeof CreateDataDataTypeEnum[keyof typeof CreateDataDataTypeEnum];

/**
 * 
 * @export
 * @interface CreateDownloadRule
 */
export interface CreateDownloadRule {
    /**
     * 
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateDownloadRule
     */
    'active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'description'?: string | null;
    /**
     * Defines the order of the rule.
     * @type {number}
     * @memberof CreateDownloadRule
     */
    'sequence': number;
    /**
     * Regular expression to filter which format this rule applies to.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'formatCode'?: string | null;
    /**
     * Regular expression to filter which project this rule applies to.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'projectName'?: string | null;
    /**
     * The local folder where to write the data.
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'targetLocalFolder': string;
    /**
     * Will allow the filename to be modified including a set of variables
     * @type {string}
     * @memberof CreateDownloadRule
     */
    'fileNameExpression'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateNextflowAnalysis
 */
export interface CreateNextflowAnalysis {
    /**
     * The user-reference of the analysis. This should be something meaningful for the user.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'userReference': string;
    /**
     * The pipeline for which an analysis will be created.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'pipelineId': string;
    /**
     * 
     * @type {AnalysisTag}
     * @memberof CreateNextflowAnalysis
     */
    'tags': AnalysisTag;
    /**
     * Indicates under which activation code the pipeline is executed.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'activationCodeDetailId': string;
    /**
     * The id of the storage to use for the analysis.
     * @type {string}
     * @memberof CreateNextflowAnalysis
     */
    'analysisStorageId'?: string | null;
    /**
     * 
     * @type {NextflowAnalysisInput}
     * @memberof CreateNextflowAnalysis
     */
    'analysisInput': NextflowAnalysisInput;
}
/**
 * 
 * @export
 * @interface CreateNotificationChannel
 */
export interface CreateNotificationChannel {
    /**
     * Should this channel be enabled or not?
     * @type {boolean}
     * @memberof CreateNotificationChannel
     */
    'enabled': boolean;
    /**
     * The type of delivery target (MAIL, SQS, SNS, HTTP, ...)
     * @type {string}
     * @memberof CreateNotificationChannel
     */
    'type': CreateNotificationChannelTypeEnum;
    /**
     * The address where to send a notification to (email address, url, ...)
     * @type {string}
     * @memberof CreateNotificationChannel
     */
    'address': string;
}

export const CreateNotificationChannelTypeEnum = {
    Mail: 'MAIL',
    Sqs: 'SQS',
    Sns: 'SNS',
    Http: 'HTTP'
} as const;

export type CreateNotificationChannelTypeEnum = typeof CreateNotificationChannelTypeEnum[keyof typeof CreateNotificationChannelTypeEnum];

/**
 * 
 * @export
 * @interface CreateNotificationSubscription
 */
export interface CreateNotificationSubscription {
    /**
     * The event code to subscribe to
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'eventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CreateNotificationSubscription
     */
    'enabled': boolean;
    /**
     * The ID of the notification channel used to send on
     * @type {string}
     * @memberof CreateNotificationSubscription
     */
    'notificationChannelId': string;
}
/**
 * 
 * @export
 * @interface CreateProject
 */
export interface CreateProject {
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'shortDescription'?: string | null;
    /**
     * Information about the project. Note that the value of this field can be arbitrary large.
     * @type {string}
     * @memberof CreateProject
     */
    'information'?: string | null;
    /**
     * Owner of the project. Defaults to the current user.
     * @type {string}
     * @memberof CreateProject
     */
    'projectOwnerId'?: string | null;
    /**
     * The region of the project. All data and pipeline executions will reside in this region.
     * @type {string}
     * @memberof CreateProject
     */
    'regionId': string;
    /**
     * The billing mode of the project. It determines who pays for the costs linked to the project.
     * @type {string}
     * @memberof CreateProject
     */
    'billingMode': CreateProjectBillingModeEnum;
    /**
     * Indicates whether the Data and Samples created in this Project can be linked to other Projects.
     * @type {boolean}
     * @memberof CreateProject
     */
    'dataSharingEnabled': boolean;
    /**
     * 
     * @type {ProjectTag}
     * @memberof CreateProject
     */
    'tags'?: ProjectTag;
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'storageBundleId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProject
     */
    'metadataModelId'?: string | null;
    /**
     * An optional storage configuration id to have self managed storage.
     * @type {string}
     * @memberof CreateProject
     */
    'storageConfigurationId'?: string | null;
    /**
     * Required when specifying a storageConfigurationId. The subfolder determines the object prefix of your self managed storage.
     * @type {string}
     * @memberof CreateProject
     */
    'storageConfigurationSubfolder'?: string | null;
}

export const CreateProjectBillingModeEnum = {
    Project: 'PROJECT',
    Tenant: 'TENANT'
} as const;

export type CreateProjectBillingModeEnum = typeof CreateProjectBillingModeEnum[keyof typeof CreateProjectBillingModeEnum];

/**
 * 
 * @export
 * @interface CreateProjectPermission
 */
export interface CreateProjectPermission {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleProject': CreateProjectPermissionRoleProjectEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleFlow': CreateProjectPermissionRoleFlowEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleBase': CreateProjectPermissionRoleBaseEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'roleBench': CreateProjectPermissionRoleBenchEnum;
    /**
     * How users are invited to the project
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'membershipType': CreateProjectPermissionMembershipTypeEnum;
    /**
     * the id of the user that should be given access, required when membershipType is USER
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'userId'?: string | null;
    /**
     * The email to invite a user on, required when membershipType is EMAIL
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'emailAddress'?: string | null;
    /**
     * the id of the workgroup to give access, required when membershipType is WORKGROUP
     * @type {string}
     * @memberof CreateProjectPermission
     */
    'workgroupId'?: string | null;
    /**
     * Indicates if uploading data is allowed or not.
     * @type {boolean}
     * @memberof CreateProjectPermission
     */
    'uploadAllowed': boolean;
    /**
     * Indicates if downloading data is allowed or not.
     * @type {boolean}
     * @memberof CreateProjectPermission
     */
    'downloadAllowed': boolean;
}

export const CreateProjectPermissionRoleProjectEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR',
    Administrator: 'ADMINISTRATOR',
    DataProvider: 'DATA_PROVIDER'
} as const;

export type CreateProjectPermissionRoleProjectEnum = typeof CreateProjectPermissionRoleProjectEnum[keyof typeof CreateProjectPermissionRoleProjectEnum];
export const CreateProjectPermissionRoleFlowEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
} as const;

export type CreateProjectPermissionRoleFlowEnum = typeof CreateProjectPermissionRoleFlowEnum[keyof typeof CreateProjectPermissionRoleFlowEnum];
export const CreateProjectPermissionRoleBaseEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
} as const;

export type CreateProjectPermissionRoleBaseEnum = typeof CreateProjectPermissionRoleBaseEnum[keyof typeof CreateProjectPermissionRoleBaseEnum];
export const CreateProjectPermissionRoleBenchEnum = {
    None: 'NONE',
    Contributor: 'CONTRIBUTOR'
} as const;

export type CreateProjectPermissionRoleBenchEnum = typeof CreateProjectPermissionRoleBenchEnum[keyof typeof CreateProjectPermissionRoleBenchEnum];
export const CreateProjectPermissionMembershipTypeEnum = {
    User: 'USER',
    Email: 'EMAIL',
    Workgroup: 'WORKGROUP'
} as const;

export type CreateProjectPermissionMembershipTypeEnum = typeof CreateProjectPermissionMembershipTypeEnum[keyof typeof CreateProjectPermissionMembershipTypeEnum];

/**
 * 
 * @export
 * @interface CreateSample
 */
export interface CreateSample {
    /**
     * The name of the sample.
     * @type {string}
     * @memberof CreateSample
     */
    'name': string;
    /**
     * The description of the sample.
     * @type {string}
     * @memberof CreateSample
     */
    'description'?: string | null;
    /**
     * 
     * @type {SampleTag}
     * @memberof CreateSample
     */
    'tags'?: SampleTag;
}
/**
 * 
 * @export
 * @interface CreateStorageConfiguration
 */
export interface CreateStorageConfiguration {
    /**
     * The name of the configuration
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'description'?: string | null;
    /**
     * The id of the storage credential
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'storageCredentialId': string;
    /**
     * The type of configuration
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'type': CreateStorageConfigurationTypeEnum;
    /**
     * 
     * @type {AWSDetails}
     * @memberof CreateStorageConfiguration
     */
    'awsDetails'?: AWSDetails | null;
    /**
     * The id of the region where the bucket will be located
     * @type {string}
     * @memberof CreateStorageConfiguration
     */
    'regionId': string;
}

export const CreateStorageConfigurationTypeEnum = {
    AwsS3: 'AWS_S3'
} as const;

export type CreateStorageConfigurationTypeEnum = typeof CreateStorageConfigurationTypeEnum[keyof typeof CreateStorageConfigurationTypeEnum];

/**
 * 
 * @export
 * @interface CreateStorageCredential
 */
export interface CreateStorageCredential {
    /**
     * The name of the credentials
     * @type {string}
     * @memberof CreateStorageCredential
     */
    'name': string;
    /**
     * The type of the credentials
     * @type {string}
     * @memberof CreateStorageCredential
     */
    'type': CreateStorageCredentialTypeEnum;
    /**
     * 
     * @type {AwsCredentials}
     * @memberof CreateStorageCredential
     */
    'awsCredentials'?: AwsCredentials | null;
}

export const CreateStorageCredentialTypeEnum = {
    AwsUser: 'AWS_USER'
} as const;

export type CreateStorageCredentialTypeEnum = typeof CreateStorageCredentialTypeEnum[keyof typeof CreateStorageCredentialTypeEnum];

/**
 * 
 * @export
 * @interface CreateTemporaryCredentials
 */
export interface CreateTemporaryCredentials {
    /**
     * The format in which temporary credentials have to be returned. If not provided, temporary credentials will be returned in a cloud specific format.
     * @type {string}
     * @memberof CreateTemporaryCredentials
     */
    'credentialsFormat'?: CreateTemporaryCredentialsCredentialsFormatEnum;
}

export const CreateTemporaryCredentialsCredentialsFormatEnum = {
    Rclone: 'RCLONE'
} as const;

export type CreateTemporaryCredentialsCredentialsFormatEnum = typeof CreateTemporaryCredentialsCredentialsFormatEnum[keyof typeof CreateTemporaryCredentialsCredentialsFormatEnum];

/**
 * 
 * @export
 * @interface CreateUploadRule
 */
export interface CreateUploadRule {
    /**
     * 
     * @type {string}
     * @memberof CreateUploadRule
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUploadRule
     */
    'active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUploadRule
     */
    'description'?: string | null;
    /**
     * The local folder to monitor. Files in this folder on your local environment will be uploaded to the specified project. Only files matching the filePattern will be uploaded.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'localFolder': string;
    /**
     * The regular expression to match a file name. eg: to match all files use \'.*\'
     * @type {string}
     * @memberof CreateUploadRule
     */
    'filePattern': string;
    /**
     * The format which will be assigned to the uploaded data. If not specified, an auto-detection of the format will be done.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'dataFormatId'?: string | null;
    /**
     * The project to which the data will be uploaded.
     * @type {string}
     * @memberof CreateUploadRule
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface CustomNotificationSubscription
 */
export interface CustomNotificationSubscription {
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'tenantName'?: string | null;
    /**
     * The custom event code to subscribe to
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'customEventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof CustomNotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof CustomNotificationSubscription
     */
    'enabled': boolean;
    /**
     * 
     * @type {NotificationChannel}
     * @memberof CustomNotificationSubscription
     */
    'notificationChannel': NotificationChannel;
}
/**
 * 
 * @export
 * @interface CustomNotificationSubscriptionList
 */
export interface CustomNotificationSubscriptionList {
    /**
     * 
     * @type {Array<CustomNotificationSubscription>}
     * @memberof CustomNotificationSubscriptionList
     */
    'items': Array<CustomNotificationSubscription>;
}
/**
 * @type CwlAnalysisInput
 * This object contains a \"oneOf\" construct. With the \"objectType\" attribute you can specify which object type you want to provide. Use \"STRUCTURED\" for type \"CreateAnalysisStructuredInput\" or use \"JSON\" for type \"CreateAnalysisJsonInput\".
 * @export
 */
export type CwlAnalysisInput = CwlAnalysisJsonInput | CwlAnalysisStructuredInput;

/**
 * 
 * @export
 * @interface CwlAnalysisJsonInput
 */
export interface CwlAnalysisJsonInput {
    /**
     * 
     * @type {string}
     * @memberof CwlAnalysisJsonInput
     */
    'objectType': CwlAnalysisJsonInputObjectTypeEnum;
    /**
     * Contains the input JSON, as an escaped JSON String.
     * @type {string}
     * @memberof CwlAnalysisJsonInput
     */
    'inputJson': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CwlAnalysisJsonInput
     */
    'dataIds'?: Array<string> | null;
}

export const CwlAnalysisJsonInputObjectTypeEnum = {
    Structured: 'STRUCTURED',
    Json: 'JSON'
} as const;

export type CwlAnalysisJsonInputObjectTypeEnum = typeof CwlAnalysisJsonInputObjectTypeEnum[keyof typeof CwlAnalysisJsonInputObjectTypeEnum];

/**
 * 
 * @export
 * @interface CwlAnalysisStructuredInput
 */
export interface CwlAnalysisStructuredInput {
    /**
     * 
     * @type {string}
     * @memberof CwlAnalysisStructuredInput
     */
    'objectType': CwlAnalysisStructuredInputObjectTypeEnum;
    /**
     * 
     * @type {Array<AnalysisDataInput>}
     * @memberof CwlAnalysisStructuredInput
     */
    'inputs': Array<AnalysisDataInput>;
    /**
     * 
     * @type {Array<AnalysisParameter>}
     * @memberof CwlAnalysisStructuredInput
     */
    'parameters'?: Array<AnalysisParameter> | null;
    /**
     * 
     * @type {Array<AnalysisReferenceDataParameter>}
     * @memberof CwlAnalysisStructuredInput
     */
    'referenceDataParameters'?: Array<AnalysisReferenceDataParameter> | null;
}

export const CwlAnalysisStructuredInputObjectTypeEnum = {
    Structured: 'STRUCTURED',
    Json: 'JSON'
} as const;

export type CwlAnalysisStructuredInputObjectTypeEnum = typeof CwlAnalysisStructuredInputObjectTypeEnum[keyof typeof CwlAnalysisStructuredInputObjectTypeEnum];

/**
 * 
 * @export
 * @interface CwlToolDefinitionList
 */
export interface CwlToolDefinitionList {
    /**
     * 
     * @type {Array<CWLToolDefinition>}
     * @memberof CwlToolDefinitionList
     */
    'items': Array<CWLToolDefinition>;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * The id of the file/folder as it was uploaded.
     * @type {string}
     * @memberof Data
     */
    'id': string;
    /**
     * 
     * @type {DataDetails}
     * @memberof Data
     */
    'details'?: DataDetails | null;
}
/**
 * The details of this data. This object is optional because it is possible that these details are deleted.
 * @export
 * @interface DataDetails
 */
export interface DataDetails {
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'owningProjectId': string;
    /**
     * The name of the file/folder as it was uploaded.
     * @type {string}
     * @memberof DataDetails
     */
    'name': string;
    /**
     * The user friendly path of the parent of this data.
     * @type {string}
     * @memberof DataDetails
     */
    'path'?: string | null;
    /**
     * The size of the file in bytes. Folders do not have a size.
     * @type {number}
     * @memberof DataDetails
     */
    'fileSizeInBytes'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'status': DataDetailsStatusEnum;
    /**
     * 
     * @type {DataTag}
     * @memberof DataDetails
     */
    'tags': DataTag;
    /**
     * 
     * @type {DataFormat}
     * @memberof DataDetails
     */
    'format'?: DataFormat | null;
    /**
     * 
     * @type {string}
     * @memberof DataDetails
     */
    'dataType': DataDetailsDataTypeEnum;
    /**
     * The file\'s ETag, as received from the cloud provider. Not to be confused with the ETag reponse header of this API.
     * @type {string}
     * @memberof DataDetails
     */
    'objectETag'?: string | null;
    /**
     * Specifies when the data object was stored for the first time
     * @type {string}
     * @memberof DataDetails
     */
    'storedForTheFirstTimeAt'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof DataDetails
     */
    'region'?: Region;
    /**
     * Specifies when the data object will be archived.
     * @type {string}
     * @memberof DataDetails
     */
    'willBeArchivedAt'?: string | null;
    /**
     * Specifies when the data object will be deleted.
     * @type {string}
     * @memberof DataDetails
     */
    'willBeDeletedAt'?: string | null;
}

export const DataDetailsStatusEnum = {
    Partial: 'PARTIAL',
    Available: 'AVAILABLE',
    Archiving: 'ARCHIVING',
    Archived: 'ARCHIVED',
    Unarchiving: 'UNARCHIVING',
    Deleting: 'DELETING'
} as const;

export type DataDetailsStatusEnum = typeof DataDetailsStatusEnum[keyof typeof DataDetailsStatusEnum];
export const DataDetailsDataTypeEnum = {
    File: 'FILE',
    Folder: 'FOLDER'
} as const;

export type DataDetailsDataTypeEnum = typeof DataDetailsDataTypeEnum[keyof typeof DataDetailsDataTypeEnum];

/**
 * 
 * @export
 * @interface DataFormat
 */
export interface DataFormat {
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'tenantName'?: string | null;
    /**
     * The code of the format. For example: FASTQ, BAM, ...
     * @type {string}
     * @memberof DataFormat
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DataFormat
     */
    'mimeType'?: string | null;
}
/**
 * 
 * @export
 * @interface DataFormatPagedList
 */
export interface DataFormatPagedList {
    /**
     * 
     * @type {Array<DataFormat>}
     * @memberof DataFormatPagedList
     */
    'items': Array<DataFormat>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof DataFormatPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof DataFormatPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof DataFormatPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface DataList
 */
export interface DataList {
    /**
     * 
     * @type {Array<Data>}
     * @memberof DataList
     */
    'items': Array<Data>;
}
/**
 * 
 * @export
 * @interface DataPagedList
 */
export interface DataPagedList {
    /**
     * 
     * @type {Array<Data>}
     * @memberof DataPagedList
     */
    'items': Array<Data>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof DataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof DataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof DataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface DataTag
 */
export interface DataTag {
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'technicalTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'userTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'connectorTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'runInTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'runOutTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataTag
     */
    'referenceTags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DataTransfer
 */
export interface DataTransfer {
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'reference': string;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'direction': DataTransferDirectionEnum;
    /**
     * 
     * @type {Connector}
     * @memberof DataTransfer
     */
    'connector'?: Connector | null;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'protocol'?: DataTransferProtocolEnum;
    /**
     * The data transferred so far in bytes.
     * @type {number}
     * @memberof DataTransfer
     */
    'dataTransferred': number;
    /**
     * 
     * @type {string}
     * @memberof DataTransfer
     */
    'status': DataTransferStatusEnum;
    /**
     * A message explaining the reason why the transfer is in the current status.
     * @type {string}
     * @memberof DataTransfer
     */
    'statusMessage'?: string | null;
    /**
     * The overall duration of of the transfer defined in seconds.
     * @type {number}
     * @memberof DataTransfer
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Project}
     * @memberof DataTransfer
     */
    'project'?: Project;
    /**
     * 
     * @type {Data}
     * @memberof DataTransfer
     */
    'data': Data;
}

export const DataTransferDirectionEnum = {
    Upload: 'UPLOAD',
    Download: 'DOWNLOAD',
    Import: 'IMPORT'
} as const;

export type DataTransferDirectionEnum = typeof DataTransferDirectionEnum[keyof typeof DataTransferDirectionEnum];
export const DataTransferProtocolEnum = {
    Https: 'HTTPS'
} as const;

export type DataTransferProtocolEnum = typeof DataTransferProtocolEnum[keyof typeof DataTransferProtocolEnum];
export const DataTransferStatusEnum = {
    Requested: 'REQUESTED',
    Ongoing: 'ONGOING',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED',
    Aborted: 'ABORTED',
    Abortrequested: 'ABORTREQUESTED',
    Scheduled: 'SCHEDULED'
} as const;

export type DataTransferStatusEnum = typeof DataTransferStatusEnum[keyof typeof DataTransferStatusEnum];

/**
 * 
 * @export
 * @interface DataTransfers
 */
export interface DataTransfers {
    /**
     * 
     * @type {Array<DataTransfer>}
     * @memberof DataTransfers
     */
    'dataTransfers': Array<DataTransfer>;
}
/**
 * 
 * @export
 * @interface Download
 */
export interface Download {
    /**
     * A pre-signed url which is temporarily available for downloading the data.
     * @type {string}
     * @memberof Download
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface DownloadRule
 */
export interface DownloadRule {
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof DownloadRule
     */
    'active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof DownloadRule
     */
    'description'?: string | null;
    /**
     * Defines the order of the rule.
     * @type {number}
     * @memberof DownloadRule
     */
    'sequence': number;
    /**
     * Regular expression to select which format this rule applies to.
     * @type {string}
     * @memberof DownloadRule
     */
    'formatCode'?: string | null;
    /**
     * Regular expression to select which project this rule applies to.
     * @type {string}
     * @memberof DownloadRule
     */
    'projectName'?: string | null;
    /**
     * The local folder where to write the data.
     * @type {string}
     * @memberof DownloadRule
     */
    'targetLocalFolder': string;
    /**
     * Will allow the filename to be modified including a set of variables
     * @type {string}
     * @memberof DownloadRule
     */
    'fileNameExpression'?: string | null;
}
/**
 * 
 * @export
 * @interface DownloadRuleList
 */
export interface DownloadRuleList {
    /**
     * 
     * @type {Array<DownloadRule>}
     * @memberof DownloadRuleList
     */
    'items': Array<DownloadRule>;
}
/**
 * 
 * @export
 * @interface EventCode
 */
export interface EventCode {
    /**
     * The event code that can be used for creating event subscriptions
     * @type {string}
     * @memberof EventCode
     */
    'eventCode': string;
    /**
     * A short description about the event code
     * @type {string}
     * @memberof EventCode
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface EventCodeList
 */
export interface EventCodeList {
    /**
     * 
     * @type {Array<EventCode>}
     * @memberof EventCodeList
     */
    'items': Array<EventCode>;
}
/**
 * 
 * @export
 * @interface EventLog
 */
export interface EventLog {
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'tenantName'?: string | null;
    /**
     * The code of the event
     * @type {string}
     * @memberof EventLog
     */
    'code': string;
    /**
     * The details of the event
     * @type {string}
     * @memberof EventLog
     */
    'description': string;
    /**
     * The type of the event
     * @type {string}
     * @memberof EventLog
     */
    'eventTypeCategory': EventLogEventTypeCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof EventLog
     */
    'userId': string;
}

export const EventLogEventTypeCategoryEnum = {
    Error: 'ERROR',
    Warn: 'WARN',
    Info: 'INFO'
} as const;

export type EventLogEventTypeCategoryEnum = typeof EventLogEventTypeCategoryEnum[keyof typeof EventLogEventTypeCategoryEnum];

/**
 * 
 * @export
 * @interface EventLogList
 */
export interface EventLogList {
    /**
     * 
     * @type {Array<EventLog>}
     * @memberof EventLogList
     */
    'items': Array<EventLog>;
}
/**
 * 
 * @export
 * @interface ExecutionConfiguration
 */
export interface ExecutionConfiguration {
    /**
     * The name of the configuration
     * @type {string}
     * @memberof ExecutionConfiguration
     */
    'name': string;
    /**
     * Whether the configuration has multiple values
     * @type {boolean}
     * @memberof ExecutionConfiguration
     */
    'multiValue': boolean;
    /**
     * The configuration values
     * @type {Array<string>}
     * @memberof ExecutionConfiguration
     */
    'values': Array<string>;
}
/**
 * 
 * @export
 * @interface ExecutionConfigurationList
 */
export interface ExecutionConfigurationList {
    /**
     * 
     * @type {Array<ExecutionConfiguration>}
     * @memberof ExecutionConfigurationList
     */
    'items': Array<ExecutionConfiguration>;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'fieldType'?: FieldFieldTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    'multivalued'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Field
     */
    'filledByPipeline'?: boolean;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Field
     */
    'fields'?: Array<Field>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Field
     */
    'enumerationValues'?: Array<string>;
}

export const FieldFieldTypeEnum = {
    Text: 'TEXT',
    Numeric: 'NUMERIC',
    Boolean: 'BOOLEAN',
    Date: 'DATE',
    Enumeration: 'ENUMERATION',
    Fieldgroup: 'FIELDGROUP',
    PipelineReference: 'PIPELINE_REFERENCE'
} as const;

export type FieldFieldTypeEnum = typeof FieldFieldTypeEnum[keyof typeof FieldFieldTypeEnum];

/**
 * The field ID to be updated. Either the field ID or field name is required.
 * @export
 * @interface FieldId
 */
export interface FieldId {
    /**
     * 
     * @type {string}
     * @memberof FieldId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FieldList
 */
export interface FieldList {
    /**
     * 
     * @type {Array<Field>}
     * @memberof FieldList
     */
    'items': Array<Field>;
}
/**
 * 
 * @export
 * @interface FindProjectSamples
 */
export interface FindProjectSamples {
    /**
     * Adds a condition on a string field.
     * @type {Array<FindSampleCondition>}
     * @memberof FindProjectSamples
     */
    'conditions': Array<FindSampleCondition>;
    /**
     * Adds a condition on a date metadate field. If both the dateBefore and dateAfter parameter are null it will return any sample that has no value for the date field.
     * @type {Array<FindSampleDateCondition>}
     * @memberof FindProjectSamples
     */
    'dateConditions': Array<FindSampleDateCondition>;
    /**
     * Adds a condition on a number metadata field. If both the lowerBoundary and upperBoundary parameter are null it will return any sample that has no value for the number field.
     * @type {Array<FindSampleNumberCondition>}
     * @memberof FindProjectSamples
     */
    'numberConditions': Array<FindSampleNumberCondition>;
    /**
     * Adds a condition on a boolean field.
     * @type {Array<FindSampleBooleanCondition>}
     * @memberof FindProjectSamples
     */
    'booleanConditions': Array<FindSampleBooleanCondition>;
    /**
     * Adds a fuzzy matching condition for the text on all string fields of the sample i.e. on both the fixed fields (name, description) as any metadata text field.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'fullTextSearchString'?: string | null;
    /**
     * Indicates whether deleted samples should be included.
     * @type {boolean}
     * @memberof FindProjectSamples
     */
    'includeDeleted'?: boolean | null;
    /**
     * The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'userTags'?: Array<string> | null;
    /**
     * How the usertags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'userTagMatchMode'?: FindProjectSamplesUserTagMatchModeEnum;
    /**
     * The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'runInputTags'?: Array<string> | null;
    /**
     * How the runInputTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'runInputTagMatchMode'?: FindProjectSamplesRunInputTagMatchModeEnum;
    /**
     * The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'connectorTags'?: Array<string> | null;
    /**
     * How the connectorTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'connectorTagMatchMode'?: FindProjectSamplesConnectorTagMatchModeEnum;
    /**
     * The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @type {Array<string>}
     * @memberof FindProjectSamples
     */
    'techTags'?: Array<string> | null;
    /**
     * How the technicalTags are filtered.
     * @type {string}
     * @memberof FindProjectSamples
     */
    'techTagMatchMode'?: FindProjectSamplesTechTagMatchModeEnum;
}

export const FindProjectSamplesUserTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
} as const;

export type FindProjectSamplesUserTagMatchModeEnum = typeof FindProjectSamplesUserTagMatchModeEnum[keyof typeof FindProjectSamplesUserTagMatchModeEnum];
export const FindProjectSamplesRunInputTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
} as const;

export type FindProjectSamplesRunInputTagMatchModeEnum = typeof FindProjectSamplesRunInputTagMatchModeEnum[keyof typeof FindProjectSamplesRunInputTagMatchModeEnum];
export const FindProjectSamplesConnectorTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
} as const;

export type FindProjectSamplesConnectorTagMatchModeEnum = typeof FindProjectSamplesConnectorTagMatchModeEnum[keyof typeof FindProjectSamplesConnectorTagMatchModeEnum];
export const FindProjectSamplesTechTagMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
} as const;

export type FindProjectSamplesTechTagMatchModeEnum = typeof FindProjectSamplesTechTagMatchModeEnum[keyof typeof FindProjectSamplesTechTagMatchModeEnum];

/**
 * Adds a condition on a boolean field.
 * @export
 * @interface FindSampleBooleanCondition
 */
export interface FindSampleBooleanCondition {
    /**
     * 
     * @type {Field}
     * @memberof FindSampleBooleanCondition
     */
    'metadataField'?: Field;
    /**
     * 
     * @type {string}
     * @memberof FindSampleBooleanCondition
     */
    'field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleBooleanCondition
     */
    'value'?: string | null;
}
/**
 * Adds a condition on a string field.
 * @export
 * @interface FindSampleCondition
 */
export interface FindSampleCondition {
    /**
     * 
     * @type {FieldId}
     * @memberof FindSampleCondition
     */
    'metadataField'?: FieldId | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleCondition
     */
    'field'?: string | null;
    /**
     * Defines how the value will be matched.
     * @type {string}
     * @memberof FindSampleCondition
     */
    'matchMode'?: FindSampleConditionMatchModeEnum;
    /**
     * 
     * @type {Set<string>}
     * @memberof FindSampleCondition
     */
    'values': Set<string>;
}

export const FindSampleConditionMatchModeEnum = {
    Exact: 'EXACT',
    Exclude: 'EXCLUDE',
    Fuzzy: 'FUZZY'
} as const;

export type FindSampleConditionMatchModeEnum = typeof FindSampleConditionMatchModeEnum[keyof typeof FindSampleConditionMatchModeEnum];

/**
 * Adds a condition on a date metadate field. If both the dateBefore and dateAfter parameter are null it will return any sample that has no value for the date field.
 * @export
 * @interface FindSampleDateCondition
 */
export interface FindSampleDateCondition {
    /**
     * 
     * @type {FieldId}
     * @memberof FindSampleDateCondition
     */
    'metadataField'?: FieldId | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'beforeDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleDateCondition
     */
    'afterDate'?: string | null;
}
/**
 * Adds a condition on a number metadata field. If both the lowerBoundary and upperBoundary parameter are null it will return any sample that has no value for the number field.
 * @export
 * @interface FindSampleNumberCondition
 */
export interface FindSampleNumberCondition {
    /**
     * 
     * @type {FieldId}
     * @memberof FindSampleNumberCondition
     */
    'metadataField'?: FieldId | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'lowerBound'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSampleNumberCondition
     */
    'upperBound'?: string | null;
}
/**
 * 
 * @export
 * @interface FolderUploadSession
 */
export interface FolderUploadSession {
    /**
     * The id of the folder upload session.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'id': string;
    /**
     * The time the folder upload session was created.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeCreated': string;
    /**
     * The status of the folder upload session.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'status': FolderUploadSessionStatusEnum;
    /**
     * The time the folder upload session will expire as it is only temporarily valid.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeSessionExpires': string;
    /**
     * The time the folder upload session completed.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeCompleted'?: string | null;
    /**
     * The time the folder upload session was closed.
     * @type {string}
     * @memberof FolderUploadSession
     */
    'timeClosed'?: string | null;
    /**
     * 
     * @type {TempCredentials}
     * @memberof FolderUploadSession
     */
    'tempCredentials'?: TempCredentials | null;
}

export const FolderUploadSessionStatusEnum = {
    Open: 'OPEN',
    Closed: 'CLOSED',
    Completed: 'COMPLETED'
} as const;

export type FolderUploadSessionStatusEnum = typeof FolderUploadSessionStatusEnum[keyof typeof FolderUploadSessionStatusEnum];

/**
 * 
 * @export
 * @interface InlineView
 */
export interface InlineView {
    /**
     * A pre-signed url which is temporarily available for inline viewing the data.
     * @type {string}
     * @memberof InlineView
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InputParameter
 */
export interface InputParameter {
    /**
     * The ID of the parameter
     * @type {string}
     * @memberof InputParameter
     */
    'id': string;
    /**
     * The code of the parameter
     * @type {string}
     * @memberof InputParameter
     */
    'code': string;
    /**
     * Indicates whether this parameter is required
     * @type {boolean}
     * @memberof InputParameter
     */
    'required': boolean;
    /**
     * Indicates whether multiple values are allowed for this parameter
     * @type {boolean}
     * @memberof InputParameter
     */
    'multiValue': boolean;
}
/**
 * 
 * @export
 * @interface InputParameterList
 */
export interface InputParameterList {
    /**
     * 
     * @type {Array<InputParameter>}
     * @memberof InputParameterList
     */
    'items': Array<InputParameter>;
}
/**
 * 
 * @export
 * @interface InputPart
 */
export interface InputPart {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InputPart
     */
    'headers'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {InputPartMediaType}
     * @memberof InputPart
     */
    'mediaType'?: InputPartMediaType;
    /**
     * 
     * @type {string}
     * @memberof InputPart
     */
    'bodyAsString'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InputPart
     */
    'contentTypeFromMessage'?: boolean;
}
/**
 * 
 * @export
 * @interface InputPartMediaType
 */
export interface InputPartMediaType {
    /**
     * 
     * @type {string}
     * @memberof InputPartMediaType
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InputPartMediaType
     */
    'subtype'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InputPartMediaType
     */
    'parameters'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof InputPartMediaType
     */
    'wildcardType'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InputPartMediaType
     */
    'wildcardSubtype'?: boolean;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * The name of the link
     * @type {string}
     * @memberof Link
     */
    'name': string;
    /**
     * The url of the link
     * @type {string}
     * @memberof Link
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {Array<Link>}
     * @memberof Links
     */
    'links'?: Array<Link>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof Links
     */
    'licenses'?: Array<Link>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof Links
     */
    'homepages'?: Array<Link>;
    /**
     * 
     * @type {Array<Link>}
     * @memberof Links
     */
    'publications'?: Array<Link>;
}
/**
 * 
 * @export
 * @interface LoadDataInBaseRequest
 */
export interface LoadDataInBaseRequest {
    /**
     * Enable to accept rows that are missing trailing optional columns. Missing values will be treated as nulls.
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'allowJaggedRows'?: boolean | null;
    /**
     * Enable to include newlines contained in quoted data sections in the cells value. When disabled, newlines will signal a new row
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'allowQuotedNewlines'?: boolean | null;
    /**
     * ID of the data to load into the table
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'dataId': string;
    /**
     * field delimiter
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'delimiter'?: string | null;
    /**
     * Encoding
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'encoding'?: LoadDataInBaseRequestEncodingEnum;
    /**
     * When false (default): the data will not be loaded if it was already previously loaded to table ; when true, the data will be loaded even if already loaded in the past
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'forceLoad'?: boolean | null;
    /**
     * number of rows to skip (usually for headers)
     * @type {number}
     * @memberof LoadDataInBaseRequest
     */
    'headerRowsToSkip'?: number | null;
    /**
     * When enabled, rows with extra column values that do not match the schema will be ignored and will not be loaded into the table
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'ignoreUnknownValues'?: boolean;
    /**
     * Include references
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeReferences'?: boolean | null;
    /**
     * Include Data Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeDataReference'?: boolean | null;
    /**
     * Include Sample Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeSampleReference'?: boolean | null;
    /**
     * Include Pipeline Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includePipelineReference'?: boolean | null;
    /**
     * Include Pipeline Execution Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includePipelineExecutionReference'?: boolean | null;
    /**
     * Include Tenant Reference
     * @type {boolean}
     * @memberof LoadDataInBaseRequest
     */
    'includeTenantReference'?: boolean | null;
    /**
     * Specifies a string that represents a null value in a CSV/TSV file.
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'nullMarker'?: string | null;
    /**
     * The maximum number of bad records that Base can ignore when running the job
     * @type {number}
     * @memberof LoadDataInBaseRequest
     */
    'numberOfErrorsAllowed'?: number | null;
    /**
     * The value that is used to quote data sections in a CSV/TSV file
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'quote'?: string | null;
    /**
     * specifies how to write data in the table.
     * @type {string}
     * @memberof LoadDataInBaseRequest
     */
    'writePreference'?: LoadDataInBaseRequestWritePreferenceEnum;
}

export const LoadDataInBaseRequestEncodingEnum = {
    Utf8: 'UTF8',
    Iso88591: 'ISO88591'
} as const;

export type LoadDataInBaseRequestEncodingEnum = typeof LoadDataInBaseRequestEncodingEnum[keyof typeof LoadDataInBaseRequestEncodingEnum];
export const LoadDataInBaseRequestWritePreferenceEnum = {
    Writeifempty: 'WRITEIFEMPTY',
    Appendtotable: 'APPENDTOTABLE',
    Overwritetable: 'OVERWRITETABLE'
} as const;

export type LoadDataInBaseRequestWritePreferenceEnum = typeof LoadDataInBaseRequestWritePreferenceEnum[keyof typeof LoadDataInBaseRequestWritePreferenceEnum];

/**
 * The metadata of the sample
 * @export
 * @interface MetadataField
 */
export interface MetadataField {
    /**
     * 
     * @type {string}
     * @memberof MetadataField
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof MetadataField
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof MetadataField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataField
     */
    'fieldType'?: MetadataFieldFieldTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataField
     */
    'values'?: Array<string>;
    /**
     * 
     * @type {Array<MetadataField>}
     * @memberof MetadataField
     */
    'groupValues'?: Array<MetadataField>;
}

export const MetadataFieldFieldTypeEnum = {
    Text: 'TEXT',
    Numeric: 'NUMERIC',
    Boolean: 'BOOLEAN',
    Date: 'DATE',
    Group: 'GROUP'
} as const;

export type MetadataFieldFieldTypeEnum = typeof MetadataFieldFieldTypeEnum[keyof typeof MetadataFieldFieldTypeEnum];

/**
 * 
 * @export
 * @interface MetadataModel
 */
export interface MetadataModel {
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'state': MetadataModelStateEnum;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'parentModelId'?: string | null;
}

export const MetadataModelStateEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED'
} as const;

export type MetadataModelStateEnum = typeof MetadataModelStateEnum[keyof typeof MetadataModelStateEnum];

/**
 * 
 * @export
 * @interface MetadataModelList
 */
export interface MetadataModelList {
    /**
     * 
     * @type {Array<MetadataModel>}
     * @memberof MetadataModelList
     */
    'items': Array<MetadataModel>;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'state'?: ModelStateEnum;
    /**
     * 
     * @type {Array<Model>}
     * @memberof Model
     */
    'models'?: Array<Model>;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Model
     */
    'fields'?: Array<Field>;
}

export const ModelStateEnum = {
    Draft: 'DRAFT',
    Published: 'PUBLISHED'
} as const;

export type ModelStateEnum = typeof ModelStateEnum[keyof typeof ModelStateEnum];

/**
 * 
 * @export
 * @interface MultipartFormDataInput
 */
export interface MultipartFormDataInput {
    /**
     * 
     * @type {{ [key: string]: InputPart; }}
     * @memberof MultipartFormDataInput
     */
    'formData'?: { [key: string]: InputPart; };
    /**
     * 
     * @type {{ [key: string]: Array<InputPart>; }}
     * @memberof MultipartFormDataInput
     */
    'formDataMap'?: { [key: string]: Array<InputPart>; };
    /**
     * 
     * @type {Array<InputPart>}
     * @memberof MultipartFormDataInput
     */
    'parts'?: Array<InputPart>;
    /**
     * 
     * @type {string}
     * @memberof MultipartFormDataInput
     */
    'preamble'?: string;
}
/**
 * 
 * @export
 * @interface NextflowAnalysisInput
 */
export interface NextflowAnalysisInput {
    /**
     * 
     * @type {Array<AnalysisDataInput>}
     * @memberof NextflowAnalysisInput
     */
    'inputs': Array<AnalysisDataInput>;
    /**
     * 
     * @type {Array<AnalysisParameter>}
     * @memberof NextflowAnalysisInput
     */
    'parameters'?: Array<AnalysisParameter> | null;
    /**
     * 
     * @type {Array<AnalysisReferenceDataParameter>}
     * @memberof NextflowAnalysisInput
     */
    'referenceDataParameters'?: Array<AnalysisReferenceDataParameter> | null;
}
/**
 * 
 * @export
 * @interface NotificationChannel
 */
export interface NotificationChannel {
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationChannel
     */
    'tenantName'?: string | null;
    /**
     * Should this channel be enabled or not?
     * @type {boolean}
     * @memberof NotificationChannel
     */
    'enabled': boolean;
    /**
     * The type of delivery target (MAIL, SQS, SNS, HTTP, ...)
     * @type {string}
     * @memberof NotificationChannel
     */
    'type': NotificationChannelTypeEnum;
    /**
     * The address where to send a notification to (email address, url, ...)
     * @type {string}
     * @memberof NotificationChannel
     */
    'address': string;
}

export const NotificationChannelTypeEnum = {
    Mail: 'MAIL',
    Sqs: 'SQS',
    Sns: 'SNS',
    Http: 'HTTP'
} as const;

export type NotificationChannelTypeEnum = typeof NotificationChannelTypeEnum[keyof typeof NotificationChannelTypeEnum];

/**
 * 
 * @export
 * @interface NotificationChannelList
 */
export interface NotificationChannelList {
    /**
     * 
     * @type {Array<NotificationChannel>}
     * @memberof NotificationChannelList
     */
    'items': Array<NotificationChannel>;
}
/**
 * 
 * @export
 * @interface NotificationSubscription
 */
export interface NotificationSubscription {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'tenantName'?: string | null;
    /**
     * The event code to subscribe to
     * @type {string}
     * @memberof NotificationSubscription
     */
    'eventCode': string;
    /**
     * To be used when a notification applies to specific conditions.
     * @type {string}
     * @memberof NotificationSubscription
     */
    'filterExpression'?: string | null;
    /**
     * Should this subscription be enabled or not?
     * @type {boolean}
     * @memberof NotificationSubscription
     */
    'enabled': boolean;
    /**
     * 
     * @type {NotificationChannel}
     * @memberof NotificationSubscription
     */
    'notificationChannel': NotificationChannel;
}
/**
 * 
 * @export
 * @interface NotificationSubscriptionList
 */
export interface NotificationSubscriptionList {
    /**
     * 
     * @type {Array<NotificationSubscription>}
     * @memberof NotificationSubscriptionList
     */
    'items': Array<NotificationSubscription>;
}
/**
 * 
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Pipeline
     */
    'tenantName'?: string | null;
    /**
     * The code of the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'code': string;
    /**
     * The description of the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'description': string;
    /**
     * The language that is used by the pipeline
     * @type {string}
     * @memberof Pipeline
     */
    'language': PipelineLanguageEnum;
    /**
     * 
     * @type {PipelineTag}
     * @memberof Pipeline
     */
    'pipelineTags': PipelineTag;
    /**
     * 
     * @type {AnalysisStorage}
     * @memberof Pipeline
     */
    'analysisStorage': AnalysisStorage;
}

export const PipelineLanguageEnum = {
    Cwl: 'CWL',
    Nextflow: 'NEXTFLOW',
    Unknown: 'UNKNOWN'
} as const;

export type PipelineLanguageEnum = typeof PipelineLanguageEnum[keyof typeof PipelineLanguageEnum];

/**
 * 
 * @export
 * @interface PipelineBundle
 */
export interface PipelineBundle {
    /**
     * 
     * @type {string}
     * @memberof PipelineBundle
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineBundle
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PipelineBundle
     */
    'maxNumberOfAllowedSlots'?: number | null;
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'activePipelines': Array<Pipeline>;
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'canceledPipelines': Array<Pipeline>;
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PipelineBundle
     */
    'retiredPipelines': Array<Pipeline>;
    /**
     * 
     * @type {Array<Region>}
     * @memberof PipelineBundle
     */
    'regions': Array<Region>;
    /**
     * 
     * @type {Array<AnalysisStorage>}
     * @memberof PipelineBundle
     */
    'analysisStorages': Array<AnalysisStorage>;
}
/**
 * 
 * @export
 * @interface PipelineList
 */
export interface PipelineList {
    /**
     * 
     * @type {Array<Pipeline>}
     * @memberof PipelineList
     */
    'items': Array<Pipeline>;
}
/**
 * 
 * @export
 * @interface PipelineTag
 */
export interface PipelineTag {
    /**
     * Technical tags
     * @type {Array<string>}
     * @memberof PipelineTag
     */
    'technicalTags': Array<string>;
}
/**
 * RFC 7807 Problem object (https://tools.ietf.org/html/rfc7807)
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'id'?: string;
    /**
     * A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type. When this member is not present, its value is assumed to be \"about:blank\".
     * @type {string}
     * @memberof Problem
     */
    'type': string;
    /**
     * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation;
     * @type {string}
     * @memberof Problem
     */
    'title': string;
    /**
     * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
     * @type {number}
     * @memberof Problem
     */
    'status': number;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof Problem
     */
    'detail'?: string;
    /**
     * A URI reference that identifies the specific occurrence of the problem.  It may or may not yield further information if dereferenced.
     * @type {string}
     * @memberof Problem
     */
    'instance'?: string;
    /**
     * Problem parameters for e.g. request body attribute validation. Not in scope of RFC 7807.
     * @type {{ [key: string]: string; }}
     * @memberof Problem
     */
    'parameters': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * Indicates whether the project is active or hidden.
     * @type {boolean}
     * @memberof Project
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'shortDescription'?: string | null;
    /**
     * Information about the project. Note that the value of this field can be arbitrary large.
     * @type {string}
     * @memberof Project
     */
    'information'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof Project
     */
    'region': Region;
    /**
     * The billing mode of the project. It determines who pays for the costs linked to the project.
     * @type {string}
     * @memberof Project
     */
    'billingMode': ProjectBillingModeEnum;
    /**
     * Indicates whether the Data and Samples created in this Project can be linked to other Projects.
     * @type {boolean}
     * @memberof Project
     */
    'dataSharingEnabled'?: boolean | null;
    /**
     * 
     * @type {ProjectTag}
     * @memberof Project
     */
    'tags': ProjectTag;
    /**
     * 
     * @type {StorageBundle}
     * @memberof Project
     */
    'storageBundle'?: StorageBundle;
    /**
     * 
     * @type {StorageConfiguration}
     * @memberof Project
     */
    'selfManagedStorageConfiguration'?: StorageConfiguration;
    /**
     * 
     * @type {MetadataModel}
     * @memberof Project
     */
    'metadataModel'?: MetadataModel | null;
    /**
     * 
     * @type {Application}
     * @memberof Project
     */
    'application'?: Application | null;
}

export const ProjectBillingModeEnum = {
    Project: 'PROJECT',
    Tenant: 'TENANT'
} as const;

export type ProjectBillingModeEnum = typeof ProjectBillingModeEnum[keyof typeof ProjectBillingModeEnum];

/**
 * 
 * @export
 * @interface ProjectBaseTable
 */
export interface ProjectBaseTable {
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'tenantName'?: string | null;
    /**
     * The name of the table which should be used in writing queries
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'name': string;
    /**
     * The description of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'description'?: string | null;
    /**
     * The type of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'type': ProjectBaseTableTypeEnum;
    /**
     * The status of the table
     * @type {string}
     * @memberof ProjectBaseTable
     */
    'status': ProjectBaseTableStatusEnum;
    /**
     * The number of record in the table
     * @type {number}
     * @memberof ProjectBaseTable
     */
    'numberOfRecords'?: number | null;
    /**
     * The amount of Data contained in this table in bytes
     * @type {number}
     * @memberof ProjectBaseTable
     */
    'dataSize'?: number | null;
}

export const ProjectBaseTableTypeEnum = {
    Table: 'TABLE',
    View: 'VIEW'
} as const;

export type ProjectBaseTableTypeEnum = typeof ProjectBaseTableTypeEnum[keyof typeof ProjectBaseTableTypeEnum];
export const ProjectBaseTableStatusEnum = {
    Available: 'AVAILABLE',
    Deleted: 'DELETED',
    Pending: 'PENDING'
} as const;

export type ProjectBaseTableStatusEnum = typeof ProjectBaseTableStatusEnum[keyof typeof ProjectBaseTableStatusEnum];

/**
 * 
 * @export
 * @interface ProjectBaseTableList
 */
export interface ProjectBaseTableList {
    /**
     * 
     * @type {Array<ProjectBaseTable>}
     * @memberof ProjectBaseTableList
     */
    'items': Array<ProjectBaseTable>;
}
/**
 * 
 * @export
 * @interface ProjectData
 */
export interface ProjectData {
    /**
     * 
     * @type {Data}
     * @memberof ProjectData
     */
    'data': Data;
    /**
     * 
     * @type {string}
     * @memberof ProjectData
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface ProjectDataPagedList
 */
export interface ProjectDataPagedList {
    /**
     * 
     * @type {Array<ProjectData>}
     * @memberof ProjectDataPagedList
     */
    'items': Array<ProjectData>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectDataPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectDataPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectDataPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface ProjectList
 */
export interface ProjectList {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectList
     */
    'items': Array<Project>;
}
/**
 * 
 * @export
 * @interface ProjectPagedList
 */
export interface ProjectPagedList {
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectPagedList
     */
    'items': Array<Project>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectPagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectPagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectPagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface ProjectPermission
 */
export interface ProjectPermission {
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleProject': ProjectPermissionRoleProjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleFlow': ProjectPermissionRoleFlowEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleBase': ProjectPermissionRoleBaseEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'roleBench': ProjectPermissionRoleBenchEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectPermission
     */
    'membershipType': ProjectPermissionMembershipTypeEnum;
    /**
     * 
     * @type {User}
     * @memberof ProjectPermission
     */
    'user'?: User;
    /**
     * Only present when membershipType is EMAIL
     * @type {string}
     * @memberof ProjectPermission
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {Workgroup}
     * @memberof ProjectPermission
     */
    'workgroup'?: Workgroup;
    /**
     * Only present when membershipType is EMAIL
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'invitationAccepted'?: boolean | null;
    /**
     * Only present when user is invited by EMAIL
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'invitationRejected'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'uploadAllowed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPermission
     */
    'downloadAllowed': boolean;
}

export const ProjectPermissionRoleProjectEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR',
    Administrator: 'ADMINISTRATOR',
    DataProvider: 'DATA_PROVIDER'
} as const;

export type ProjectPermissionRoleProjectEnum = typeof ProjectPermissionRoleProjectEnum[keyof typeof ProjectPermissionRoleProjectEnum];
export const ProjectPermissionRoleFlowEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
} as const;

export type ProjectPermissionRoleFlowEnum = typeof ProjectPermissionRoleFlowEnum[keyof typeof ProjectPermissionRoleFlowEnum];
export const ProjectPermissionRoleBaseEnum = {
    None: 'NONE',
    Viewer: 'VIEWER',
    Contributor: 'CONTRIBUTOR'
} as const;

export type ProjectPermissionRoleBaseEnum = typeof ProjectPermissionRoleBaseEnum[keyof typeof ProjectPermissionRoleBaseEnum];
export const ProjectPermissionRoleBenchEnum = {
    None: 'NONE',
    Contributor: 'CONTRIBUTOR'
} as const;

export type ProjectPermissionRoleBenchEnum = typeof ProjectPermissionRoleBenchEnum[keyof typeof ProjectPermissionRoleBenchEnum];
export const ProjectPermissionMembershipTypeEnum = {
    User: 'USER',
    Email: 'EMAIL',
    Workgroup: 'WORKGROUP'
} as const;

export type ProjectPermissionMembershipTypeEnum = typeof ProjectPermissionMembershipTypeEnum[keyof typeof ProjectPermissionMembershipTypeEnum];

/**
 * 
 * @export
 * @interface ProjectPermissionList
 */
export interface ProjectPermissionList {
    /**
     * 
     * @type {Array<ProjectPermission>}
     * @memberof ProjectPermissionList
     */
    'items': Array<ProjectPermission>;
}
/**
 * 
 * @export
 * @interface ProjectPipeline
 */
export interface ProjectPipeline {
    /**
     * 
     * @type {Pipeline}
     * @memberof ProjectPipeline
     */
    'pipeline': Pipeline;
    /**
     * 
     * @type {string}
     * @memberof ProjectPipeline
     */
    'projectId': string;
    /**
     * 
     * @type {BundleList}
     * @memberof ProjectPipeline
     */
    'bundleLinks': BundleList;
}
/**
 * 
 * @export
 * @interface ProjectPipelineList
 */
export interface ProjectPipelineList {
    /**
     * 
     * @type {Array<ProjectPipeline>}
     * @memberof ProjectPipelineList
     */
    'items': Array<ProjectPipeline>;
}
/**
 * 
 * @export
 * @interface ProjectSample
 */
export interface ProjectSample {
    /**
     * 
     * @type {Sample}
     * @memberof ProjectSample
     */
    'sample': Sample;
    /**
     * 
     * @type {string}
     * @memberof ProjectSample
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface ProjectSamplePagedList
 */
export interface ProjectSamplePagedList {
    /**
     * 
     * @type {Array<ProjectSample>}
     * @memberof ProjectSamplePagedList
     */
    'items': Array<ProjectSample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof ProjectSamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof ProjectSamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof ProjectSamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface ProjectTag
 */
export interface ProjectTag {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectTag
     */
    'technicalTags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectTag
     */
    'userTags': Array<string>;
}
/**
 * In case of providing the credentialsFormat = rclone, this will contain the credentials for uploading or downloading the data in rclone format.
 * @export
 * @interface RcloneTempCredentials
 */
export interface RcloneTempCredentials {
    /**
     * The config in key value format.
     * @type {{ [key: string]: string; }}
     * @memberof RcloneTempCredentials
     */
    'config': { [key: string]: string; };
    /**
     * The prefix of the file path.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'filePathPrefix': string;
    /**
     * The type of the object storage.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'storageType': string;
    /**
     * The timestamp when the credentials expire.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'expirationTime': string;
    /**
     * The folder upload session id which can be used after upload to complete the upload session.
     * @type {string}
     * @memberof RcloneTempCredentials
     */
    'uploadSessionId'?: string | null;
}
/**
 * 
 * @export
 * @interface ReferenceData
 */
export interface ReferenceData {
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceData
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference set
     * @type {string}
     * @memberof ReferenceData
     */
    'name': string;
    /**
     * 
     * @type {Species}
     * @memberof ReferenceData
     */
    'species'?: Species | null;
    /**
     * 
     * @type {DataFormat}
     * @memberof ReferenceData
     */
    'dataFormat'?: DataFormat | null;
    /**
     * The version of the reference set
     * @type {string}
     * @memberof ReferenceData
     */
    'version': string;
    /**
     * 
     * @type {TypeList}
     * @memberof ReferenceData
     */
    'typeList': TypeList;
}
/**
 * 
 * @export
 * @interface ReferenceDataList
 */
export interface ReferenceDataList {
    /**
     * 
     * @type {Array<ReferenceData>}
     * @memberof ReferenceDataList
     */
    'items': Array<ReferenceData>;
}
/**
 * 
 * @export
 * @interface ReferenceSet
 */
export interface ReferenceSet {
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceSet
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference set
     * @type {string}
     * @memberof ReferenceSet
     */
    'name': string;
    /**
     * 
     * @type {ReferenceDataList}
     * @memberof ReferenceSet
     */
    'referenceDataList': ReferenceDataList;
}
/**
 * 
 * @export
 * @interface ReferenceSetList
 */
export interface ReferenceSetList {
    /**
     * 
     * @type {Array<ReferenceSet>}
     * @memberof ReferenceSetList
     */
    'items': Array<ReferenceSet>;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'code': string;
    /**
     * 
     * @type {Country}
     * @memberof Region
     */
    'country': Country | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    'cityName': string;
}
/**
 * 
 * @export
 * @interface RegionList
 */
export interface RegionList {
    /**
     * 
     * @type {Array<Region>}
     * @memberof RegionList
     */
    'items': Array<Region>;
}
/**
 * 
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'tenantName'?: string | null;
    /**
     * The name of the sample
     * @type {string}
     * @memberof Sample
     */
    'name': string;
    /**
     * The description of the sample
     * @type {string}
     * @memberof Sample
     */
    'description'?: string | null;
    /**
     * 
     * @type {SampleTag}
     * @memberof Sample
     */
    'tags': SampleTag;
    /**
     * 
     * @type {Region}
     * @memberof Sample
     */
    'region': Region;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'status': SampleStatusEnum;
    /**
     * Whether the metadata is valid
     * @type {boolean}
     * @memberof Sample
     */
    'metadataValid': boolean;
    /**
     * The metadata of the sample
     * @type {Array<MetadataField>}
     * @memberof Sample
     */
    'metadata': Array<MetadataField>;
}

export const SampleStatusEnum = {
    Deleted: 'DELETED',
    Available: 'AVAILABLE',
    Partial: 'PARTIAL'
} as const;

export type SampleStatusEnum = typeof SampleStatusEnum[keyof typeof SampleStatusEnum];

/**
 * 
 * @export
 * @interface SampleHistory
 */
export interface SampleHistory {
    /**
     * When the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'occurredAt': string;
    /**
     * The user that made the change
     * @type {string}
     * @memberof SampleHistory
     */
    'user'?: string | null;
    /**
     * In which execution context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'run'?: string | null;
    /**
     * In which context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'source': string;
    /**
     * What was changed
     * @type {string}
     * @memberof SampleHistory
     */
    'text': string;
    /**
     * In which project context the change was made
     * @type {string}
     * @memberof SampleHistory
     */
    'project'?: string | null;
    /**
     * In which model context the change was made
     * @type {number}
     * @memberof SampleHistory
     */
    'model'?: number | null;
}
/**
 * 
 * @export
 * @interface SampleHistoryList
 */
export interface SampleHistoryList {
    /**
     * 
     * @type {Array<SampleHistory>}
     * @memberof SampleHistoryList
     */
    'items': Array<SampleHistory>;
}
/**
 * 
 * @export
 * @interface SamplePagedList
 */
export interface SamplePagedList {
    /**
     * 
     * @type {Array<Sample>}
     * @memberof SamplePagedList
     */
    'items': Array<Sample>;
    /**
     * The cursor to request the next page. For offset-based paging the value is an empty string.
     * @type {string}
     * @memberof SamplePagedList
     */
    'nextPageToken'?: string | null;
    /**
     * The number of records remaining (used in cursor based pagination)
     * @type {number}
     * @memberof SamplePagedList
     */
    'remainingRecords'?: number | null;
    /**
     * The total number of records matching the search criteria (used in offset based pagination)
     * @type {number}
     * @memberof SamplePagedList
     */
    'totalItemCount'?: number | null;
}
/**
 * 
 * @export
 * @interface SampleTag
 */
export interface SampleTag {
    /**
     * 
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'technicalTags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'userTags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'connectorTags': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SampleTag
     */
    'runInTags': Array<string>;
}
/**
 * 
 * @export
 * @interface ScheduleDownload
 */
export interface ScheduleDownload {
    /**
     * 
     * @type {string}
     * @memberof ScheduleDownload
     */
    'connectorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDownload
     */
    'protocol'?: ScheduleDownloadProtocolEnum;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDownload
     */
    'localPath'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleDownload
     */
    'disableHashing'?: boolean;
}

export const ScheduleDownloadProtocolEnum = {
    Https: 'HTTPS'
} as const;

export type ScheduleDownloadProtocolEnum = typeof ScheduleDownloadProtocolEnum[keyof typeof ScheduleDownloadProtocolEnum];

/**
 * 
 * @export
 * @interface SearchMatchingActivationCodesForCwlAnalysis
 */
export interface SearchMatchingActivationCodesForCwlAnalysis {
    /**
     * 
     * @type {string}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'pipelineId': string;
    /**
     * 
     * @type {CwlAnalysisInput}
     * @memberof SearchMatchingActivationCodesForCwlAnalysis
     */
    'analysisInput': CwlAnalysisInput;
}
/**
 * 
 * @export
 * @interface SearchMatchingActivationCodesForNextflowAnalysis
 */
export interface SearchMatchingActivationCodesForNextflowAnalysis {
    /**
     * 
     * @type {string}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'pipelineId': string;
    /**
     * 
     * @type {NextflowAnalysisInput}
     * @memberof SearchMatchingActivationCodesForNextflowAnalysis
     */
    'analysisInput': NextflowAnalysisInput;
}
/**
 * 
 * @export
 * @interface Species
 */
export interface Species {
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'tenantName'?: string | null;
    /**
     * The name of the species
     * @type {string}
     * @memberof Species
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StorageBundle
 */
export interface StorageBundle {
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageBundle
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage bundle
     * @type {string}
     * @memberof StorageBundle
     */
    'bundleName': string;
    /**
     * The name of the parent entitlement
     * @type {string}
     * @memberof StorageBundle
     */
    'entitlementName': string;
    /**
     * 
     * @type {Region}
     * @memberof StorageBundle
     */
    'region': Region;
}
/**
 * 
 * @export
 * @interface StorageBundleList
 */
export interface StorageBundleList {
    /**
     * 
     * @type {Array<StorageBundle>}
     * @memberof StorageBundleList
     */
    'items': Array<StorageBundle>;
}
/**
 * 
 * @export
 * @interface StorageConfiguration
 */
export interface StorageConfiguration {
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage configuration
     * @type {string}
     * @memberof StorageConfiguration
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof StorageConfiguration
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'type': StorageConfigurationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageConfiguration
     */
    'status': StorageConfigurationStatusEnum;
    /**
     * An optional error message when something went wrong with the configuration
     * @type {string}
     * @memberof StorageConfiguration
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof StorageConfiguration
     */
    'region': Region;
    /**
     * An indication if this is the default in region for new projects
     * @type {boolean}
     * @memberof StorageConfiguration
     */
    'isDefault': boolean;
}

export const StorageConfigurationTypeEnum = {
    AwsS3: 'AWS_S3'
} as const;

export type StorageConfigurationTypeEnum = typeof StorageConfigurationTypeEnum[keyof typeof StorageConfigurationTypeEnum];
export const StorageConfigurationStatusEnum = {
    Initializing: 'INITIALIZING',
    Ok: 'OK',
    Error: 'ERROR'
} as const;

export type StorageConfigurationStatusEnum = typeof StorageConfigurationStatusEnum[keyof typeof StorageConfigurationStatusEnum];

/**
 * Contains the specific provider details
 * @export
 * @interface StorageConfigurationDetails
 */
export interface StorageConfigurationDetails {
    /**
     * 
     * @type {AWSDetails}
     * @memberof StorageConfigurationDetails
     */
    'awsS3'?: AWSDetails | null;
}
/**
 * 
 * @export
 * @interface StorageConfigurationWithDetails
 */
export interface StorageConfigurationWithDetails {
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'tenantName'?: string | null;
    /**
     * The name of the storage configuration
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'name': string;
    /**
     * An optional description
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'type': StorageConfigurationWithDetailsTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'status': StorageConfigurationWithDetailsStatusEnum;
    /**
     * An optional error message when something went wrong with the configuration
     * @type {string}
     * @memberof StorageConfigurationWithDetails
     */
    'errorMessage'?: string | null;
    /**
     * 
     * @type {Region}
     * @memberof StorageConfigurationWithDetails
     */
    'region': Region;
    /**
     * An indication if this is the default in region for new projects
     * @type {boolean}
     * @memberof StorageConfigurationWithDetails
     */
    'isDefault': boolean;
    /**
     * 
     * @type {StorageConfigurationDetails}
     * @memberof StorageConfigurationWithDetails
     */
    'storageConfigurationDetails': StorageConfigurationDetails;
}

export const StorageConfigurationWithDetailsTypeEnum = {
    AwsS3: 'AWS_S3'
} as const;

export type StorageConfigurationWithDetailsTypeEnum = typeof StorageConfigurationWithDetailsTypeEnum[keyof typeof StorageConfigurationWithDetailsTypeEnum];
export const StorageConfigurationWithDetailsStatusEnum = {
    Initializing: 'INITIALIZING',
    Ok: 'OK',
    Error: 'ERROR'
} as const;

export type StorageConfigurationWithDetailsStatusEnum = typeof StorageConfigurationWithDetailsStatusEnum[keyof typeof StorageConfigurationWithDetailsStatusEnum];

/**
 * 
 * @export
 * @interface StorageConfigurationWithDetailsList
 */
export interface StorageConfigurationWithDetailsList {
    /**
     * 
     * @type {Array<StorageConfigurationWithDetails>}
     * @memberof StorageConfigurationWithDetailsList
     */
    'items': Array<StorageConfigurationWithDetails>;
}
/**
 * 
 * @export
 * @interface StorageCredential
 */
export interface StorageCredential {
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageCredential
     */
    'type': StorageCredentialTypeEnum;
}

export const StorageCredentialTypeEnum = {
    AwsUser: 'AWS_USER'
} as const;

export type StorageCredentialTypeEnum = typeof StorageCredentialTypeEnum[keyof typeof StorageCredentialTypeEnum];

/**
 * 
 * @export
 * @interface StorageCredentialList
 */
export interface StorageCredentialList {
    /**
     * 
     * @type {Array<StorageCredential>}
     * @memberof StorageCredentialList
     */
    'items': Array<StorageCredential>;
}
/**
 * 
 * @export
 * @interface TempCredentials
 */
export interface TempCredentials {
    /**
     * 
     * @type {AwsTempCredentials}
     * @memberof TempCredentials
     */
    'awsTempCredentials'?: AwsTempCredentials | null;
    /**
     * 
     * @type {RcloneTempCredentials}
     * @memberof TempCredentials
     */
    'rcloneTempCredentials'?: RcloneTempCredentials | null;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Type
 */
export interface Type {
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    'tenantName'?: string | null;
    /**
     * The name of the reference data type
     * @type {string}
     * @memberof Type
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TypeList
 */
export interface TypeList {
    /**
     * 
     * @type {Array<Type>}
     * @memberof TypeList
     */
    'items': Array<Type>;
}
/**
 * 
 * @export
 * @interface UpdateMetadata
 */
export interface UpdateMetadata {
    /**
     * List of metadata fields to be updated
     * @type {Array<UpdateSingleMetadataField>}
     * @memberof UpdateMetadata
     */
    'updateSingleMetadataFields'?: Array<UpdateSingleMetadataField> | null;
    /**
     * List of metadata field groups to be updated
     * @type {Array<UpdateMetadataFieldGroup>}
     * @memberof UpdateMetadata
     */
    'updateMetadataFieldGroups'?: Array<UpdateMetadataFieldGroup> | null;
}
/**
 * List of metadata field groups to be updated
 * @export
 * @interface UpdateMetadataFieldGroup
 */
export interface UpdateMetadataFieldGroup {
    /**
     * 
     * @type {FieldId}
     * @memberof UpdateMetadataFieldGroup
     */
    'fieldId'?: FieldId | null;
    /**
     * The field name to be updated. Either the field ID or field name is required.
     * @type {string}
     * @memberof UpdateMetadataFieldGroup
     */
    'fieldName'?: string | null;
    /**
     * Which metadata row index to update
     * @type {number}
     * @memberof UpdateMetadataFieldGroup
     */
    'index': number;
    /**
     * List of metadata fields to be updated
     * @type {Array<UpdateSingleMetadataField>}
     * @memberof UpdateMetadataFieldGroup
     */
    'updateSingleMetadataFields': Array<UpdateSingleMetadataField>;
}
/**
 * List of metadata fields to be updated
 * @export
 * @interface UpdateSingleMetadataField
 */
export interface UpdateSingleMetadataField {
    /**
     * 
     * @type {FieldId}
     * @memberof UpdateSingleMetadataField
     */
    'fieldId'?: FieldId | null;
    /**
     * The field name to be updated. Either the field ID or field name is required.
     * @type {string}
     * @memberof UpdateSingleMetadataField
     */
    'fieldName'?: string | null;
    /**
     * The updated value(s)
     * @type {Array<string>}
     * @memberof UpdateSingleMetadataField
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateStorageCredentialSecrets
 */
export interface UpdateStorageCredentialSecrets {
    /**
     * 
     * @type {AwsCredentials}
     * @memberof UpdateStorageCredentialSecrets
     */
    'awsCredentials'?: AwsCredentials | null;
}
/**
 * 
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * A pre-signed url which is temporarily available for uploading the data.
     * @type {string}
     * @memberof Upload
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UploadRule
 */
export interface UploadRule {
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'code': string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadRule
     */
    'active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UploadRule
     */
    'description'?: string | null;
    /**
     * The local folder to monitor. Files in this folder on your local environment will be uploaded to the specified project. Only files matching the filePattern will be uploaded.
     * @type {string}
     * @memberof UploadRule
     */
    'localFolder': string;
    /**
     * The regular expression to match a file name. eg: to match all files use \'.*\'
     * @type {string}
     * @memberof UploadRule
     */
    'filePattern': string;
    /**
     * 
     * @type {DataFormat}
     * @memberof UploadRule
     */
    'dataFormat'?: DataFormat | null;
    /**
     * 
     * @type {Project}
     * @memberof UploadRule
     */
    'project': Project;
}
/**
 * 
 * @export
 * @interface UploadRuleList
 */
export interface UploadRuleList {
    /**
     * 
     * @type {Array<UploadRule>}
     * @memberof UploadRuleList
     */
    'items': Array<UploadRule>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'timeCreated': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'timeModified': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'tenantName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastname'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'tenantAdministrator': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'jobTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'greeting'?: UserGreetingEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'faxNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'twoFactorAuthentication': boolean;
    /**
     * 
     * @type {Country}
     * @memberof User
     */
    'country'?: Country | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'addressLine1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'addressLine2'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'addressLine3'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'postalCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'state'?: string | null;
}

export const UserGreetingEnum = {
    Mr: 'MR',
    Mrs: 'MRS',
    Ms: 'MS',
    Miss: 'MISS',
    Dr: 'DR',
    Hr: 'HR',
    Sr: 'SR'
} as const;

export type UserGreetingEnum = typeof UserGreetingEnum[keyof typeof UserGreetingEnum];

/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    'items': Array<User>;
}
/**
 * 
 * @export
 * @interface Workgroup
 */
export interface Workgroup {
    /**
     * 
     * @type {string}
     * @memberof Workgroup
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Workgroup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Workgroup
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface WorkgroupList
 */
export interface WorkgroupList {
    /**
     * 
     * @type {Array<Workgroup>}
     * @memberof WorkgroupList
     */
    'items': Array<Workgroup>;
}

/**
 * AnalysisStorageApi - axios parameter creator
 * @export
 */
export const AnalysisStorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisStorageOptions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analysisStorages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysisStorageApi - functional programming interface
 * @export
 */
export const AnalysisStorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysisStorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisStorageOptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisStorageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisStorageOptions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalysisStorageApi - factory interface
 * @export
 */
export const AnalysisStorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysisStorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of analysis storage options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisStorageOptions(options?: any): AxiosPromise<AnalysisStorageList> {
            return localVarFp.getAnalysisStorageOptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysisStorageApi - object-oriented interface
 * @export
 * @class AnalysisStorageApi
 * @extends {BaseAPI}
 */
export class AnalysisStorageApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of analysis storage options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysisStorageApi
     */
    public getAnalysisStorageOptions(options?: AxiosRequestConfig) {
        return AnalysisStorageApiFp(this.configuration).getAnalysisStorageOptions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundleApi - axios parameter creator
 * @export
 */
export const BundleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle: async (createBundle?: CreateBundle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundle', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: async (search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userTags !== undefined) {
                localVarQueryParameter['userTags'] = userTags;
            }

            if (technicalTags !== undefined) {
                localVarQueryParameter['technicalTags'] = technicalTags;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseBundle: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('releaseBundle', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}:release`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleApi - functional programming interface
 * @export
 */
export const BundleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundle(createBundle?: CreateBundle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBundle(createBundle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundle(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundle(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundles(search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundlePagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releaseBundle(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releaseBundle(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundleApi - factory interface
 * @export
 */
export const BundleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new bundle
         * @param {CreateBundle} [createBundle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle(createBundle?: CreateBundle, options?: any): AxiosPromise<Bundle> {
            return localVarFp.createBundle(createBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a bundle.
         * @param {string} bundleId The ID of the bundle to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle(bundleId: string, options?: any): AxiosPromise<Bundle> {
            return localVarFp.getBundle(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of bundles.
         * @param {string} [search] Search
         * @param {string} [userTags] User tags to filter on
         * @param {string} [technicalTags] Technical tags to filter on
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles(search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<BundlePagedList> {
            return localVarFp.getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary release a bundle
         * @param {string} bundleId The ID of the bundle to release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseBundle(bundleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.releaseBundle(bundleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
export class BundleApi extends BaseAPI {
    /**
     * 
     * @summary Create a new bundle
     * @param {CreateBundle} [createBundle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public createBundle(createBundle?: CreateBundle, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).createBundle(createBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a bundle.
     * @param {string} bundleId The ID of the bundle to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundle(bundleId: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundle(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of bundles.
     * @param {string} [search] Search
     * @param {string} [userTags] User tags to filter on
     * @param {string} [technicalTags] Technical tags to filter on
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundles(search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundles(search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary release a bundle
     * @param {string} bundleId The ID of the bundle to release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public releaseBundle(bundleId: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).releaseBundle(bundleId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundleDataApi - axios parameter creator
 * @export
 */
export const BundleDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleData: async (bundleId: string, fullText?: string, id?: string, filename?: string, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: string, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: 'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING', formatId?: string, formatCode?: string, type?: 'FILE' | 'FOLDER', parentFolderId?: string, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: string, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: string, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: string, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: string, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: string, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: string, notLinkedToSample?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleData', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}/data`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fullText !== undefined) {
                localVarQueryParameter['fullText'] = fullText;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filenameMatchMode !== undefined) {
                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
            }

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }

            if (filePathMatchMode !== undefined) {
                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (formatId !== undefined) {
                localVarQueryParameter['formatId'] = formatId;
            }

            if (formatCode !== undefined) {
                localVarQueryParameter['formatCode'] = formatCode;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (parentFolderId !== undefined) {
                localVarQueryParameter['parentFolderId'] = parentFolderId;
            }

            if (parentFolderPath !== undefined) {
                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
            }

            if (creationDateAfter !== undefined) {
                localVarQueryParameter['creationDateAfter'] = creationDateAfter;
            }

            if (creationDateBefore !== undefined) {
                localVarQueryParameter['creationDateBefore'] = creationDateBefore;
            }

            if (statusDateAfter !== undefined) {
                localVarQueryParameter['statusDateAfter'] = statusDateAfter;
            }

            if (statusDateBefore !== undefined) {
                localVarQueryParameter['statusDateBefore'] = statusDateBefore;
            }

            if (userTag !== undefined) {
                localVarQueryParameter['userTag'] = userTag;
            }

            if (userTagMatchMode !== undefined) {
                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
            }

            if (runInputTag !== undefined) {
                localVarQueryParameter['runInputTag'] = runInputTag;
            }

            if (runInputTagMatchMode !== undefined) {
                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
            }

            if (runOutputTag !== undefined) {
                localVarQueryParameter['runOutputTag'] = runOutputTag;
            }

            if (runOutputTagMatchMode !== undefined) {
                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
            }

            if (connectorTag !== undefined) {
                localVarQueryParameter['connectorTag'] = connectorTag;
            }

            if (connectorTagMatchMode !== undefined) {
                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
            }

            if (technicalTag !== undefined) {
                localVarQueryParameter['technicalTag'] = technicalTag;
            }

            if (technicalTagMatchMode !== undefined) {
                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
            }

            if (notInRun !== undefined) {
                localVarQueryParameter['notInRun'] = notInRun;
            }

            if (notLinkedToSample !== undefined) {
                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link data to this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToBundle: async (bundleId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('linkDataToBundle', 'bundleId', bundleId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('linkDataToBundle', 'dataId', dataId)
            const localVarPath = `/api/bundles/{bundleId}/data/{dataId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink data from this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromBundle: async (bundleId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('unlinkDataFromBundle', 'bundleId', bundleId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('unlinkDataFromBundle', 'dataId', dataId)
            const localVarPath = `/api/bundles/{bundleId}/data/{dataId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleDataApi - functional programming interface
 * @export
 */
export const BundleDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundleDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleData(bundleId: string, fullText?: string, id?: string, filename?: string, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: string, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: 'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING', formatId?: string, formatCode?: string, type?: 'FILE' | 'FOLDER', parentFolderId?: string, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: string, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: string, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: string, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: string, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: string, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: string, notLinkedToSample?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleDataPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link data to this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkDataToBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkDataToBundle(bundleId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink data from this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkDataFromBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkDataFromBundle(bundleId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundleDataApi - factory interface
 * @export
 */
export const BundleDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundleDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of bundle data.
         * @param {string} bundleId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {string} [id] The ids to filter on. This will always match exact.
         * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
         * @param {string} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
         * @param {string} [formatId] The IDs of the formats to filter on.
         * @param {string} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
         * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
         * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
         * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
         * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
         * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleData(bundleId: string, fullText?: string, id?: string, filename?: string, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: string, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: 'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING', formatId?: string, formatCode?: string, type?: 'FILE' | 'FOLDER', parentFolderId?: string, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: string, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: string, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: string, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: string, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: string, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: string, notLinkedToSample?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<BundleDataPagedList> {
            return localVarFp.getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link data to this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToBundle(bundleId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkDataToBundle(bundleId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink data from this bundle.
         * @param {string} bundleId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromBundle(bundleId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkDataFromBundle(bundleId, dataId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleDataApi - object-oriented interface
 * @export
 * @class BundleDataApi
 * @extends {BaseAPI}
 */
export class BundleDataApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of bundle data.
     * @param {string} bundleId 
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {string} [id] The ids to filter on. This will always match exact.
     * @param {string} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered.
     * @param {string} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'} [status] The statuses to filter on.
     * @param {string} [formatId] The IDs of the formats to filter on.
     * @param {string} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {string} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered.
     * @param {string} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered.
     * @param {string} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered.
     * @param {string} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered.
     * @param {string} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered.
     * @param {string} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [notLinkedToSample] When set to true only date that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    public getBundleData(bundleId: string, fullText?: string, id?: string, filename?: string, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: string, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: 'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING', formatId?: string, formatCode?: string, type?: 'FILE' | 'FOLDER', parentFolderId?: string, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: string, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: string, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: string, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: string, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: string, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: string, notLinkedToSample?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return BundleDataApiFp(this.configuration).getBundleData(bundleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link data to this bundle.
     * @param {string} bundleId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    public linkDataToBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig) {
        return BundleDataApiFp(this.configuration).linkDataToBundle(bundleId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink data from this bundle.
     * @param {string} bundleId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleDataApi
     */
    public unlinkDataFromBundle(bundleId: string, dataId: string, options?: AxiosRequestConfig) {
        return BundleDataApiFp(this.configuration).unlinkDataFromBundle(bundleId, dataId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundlePipelineApi - axios parameter creator
 * @export
 */
export const BundlePipelineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlePipelines: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundlePipelines', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}/pipelines`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToBundle: async (bundleId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('linkPipelineToBundle', 'bundleId', bundleId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('linkPipelineToBundle', 'pipelineId', pipelineId)
            const localVarPath = `/api/bundles/{bundleId}/pipelines/{pipelineId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromBundle: async (bundleId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('unlinkPipelineFromBundle', 'bundleId', bundleId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('unlinkPipelineFromBundle', 'pipelineId', pipelineId)
            const localVarPath = `/api/bundles/{bundleId}/pipelines/{pipelineId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundlePipelineApi - functional programming interface
 * @export
 */
export const BundlePipelineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundlePipelineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundlePipelines(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundlePipelineList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundlePipelines(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPipelineToBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkPipelineToBundle(bundleId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkPipelineFromBundle(bundleId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundlePipelineApi - factory interface
 * @export
 */
export const BundlePipelineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundlePipelineApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle pipelines.
         * @param {string} bundleId The ID of the bundle to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlePipelines(bundleId: string, options?: any): AxiosPromise<BundlePipelineList> {
            return localVarFp.getBundlePipelines(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a pipeline to a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToBundle(bundleId: string, pipelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkPipelineToBundle(bundleId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a pipeline from a bundle.
         * @param {string} bundleId The ID of the bundle
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkPipelineFromBundle(bundleId, pipelineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundlePipelineApi - object-oriented interface
 * @export
 * @class BundlePipelineApi
 * @extends {BaseAPI}
 */
export class BundlePipelineApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of bundle pipelines.
     * @param {string} bundleId The ID of the bundle to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    public getBundlePipelines(bundleId: string, options?: AxiosRequestConfig) {
        return BundlePipelineApiFp(this.configuration).getBundlePipelines(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a pipeline to a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    public linkPipelineToBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return BundlePipelineApiFp(this.configuration).linkPipelineToBundle(bundleId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a pipeline from a bundle.
     * @param {string} bundleId The ID of the bundle
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlePipelineApi
     */
    public unlinkPipelineFromBundle(bundleId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return BundlePipelineApiFp(this.configuration).unlinkPipelineFromBundle(bundleId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundleSampleApi - axios parameter creator
 * @export
 */
export const BundleSampleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleSamples: async (bundleId: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleSamples', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}/samples`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userTags !== undefined) {
                localVarQueryParameter['userTags'] = userTags;
            }

            if (technicalTags !== undefined) {
                localVarQueryParameter['technicalTags'] = technicalTags;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a sample to a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToBundle: async (bundleId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('linkSampleToBundle', 'bundleId', bundleId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('linkSampleToBundle', 'sampleId', sampleId)
            const localVarPath = `/api/bundles/{bundleId}/samples/{sampleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromBundle: async (bundleId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('unlinkSampleFromBundle', 'bundleId', bundleId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('unlinkSampleFromBundle', 'sampleId', sampleId)
            const localVarPath = `/api/bundles/{bundleId}/samples/{sampleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleSampleApi - functional programming interface
 * @export
 */
export const BundleSampleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundleSampleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleSamples(bundleId: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleSamplePagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a sample to a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkSampleToBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkSampleToBundle(bundleId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkSampleFromBundle(bundleId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundleSampleApi - factory interface
 * @export
 */
export const BundleSampleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundleSampleApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle samples.
         * @param {string} bundleId The ID of the bundle to get bundle samples from
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleSamples(bundleId: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<BundleSamplePagedList> {
            return localVarFp.getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a sample to a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToBundle(bundleId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkSampleToBundle(bundleId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a sample from a bundle.
         * @param {string} bundleId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkSampleFromBundle(bundleId, sampleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleSampleApi - object-oriented interface
 * @export
 * @class BundleSampleApi
 * @extends {BaseAPI}
 */
export class BundleSampleApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of bundle samples.
     * @param {string} bundleId The ID of the bundle to get bundle samples from
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    public getBundleSamples(bundleId: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return BundleSampleApiFp(this.configuration).getBundleSamples(bundleId, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a sample to a bundle.
     * @param {string} bundleId 
     * @param {string} sampleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    public linkSampleToBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig) {
        return BundleSampleApiFp(this.configuration).linkSampleToBundle(bundleId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a sample from a bundle.
     * @param {string} bundleId 
     * @param {string} sampleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleSampleApi
     */
    public unlinkSampleFromBundle(bundleId: string, sampleId: string, options?: AxiosRequestConfig) {
        return BundleSampleApiFp(this.configuration).unlinkSampleFromBundle(bundleId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundleToolApi - axios parameter creator
 * @export
 */
export const BundleToolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTools: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleTools', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}/tools`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsEligibleForLinkingToBundle: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getToolsEligibleForLinkingToBundle', 'bundleId', bundleId)
            const localVarPath = `/api/bundles/{bundleId}/tools/eligibleForLinking`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkToolToBundle: async (bundleId: string, toolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('linkToolToBundle', 'bundleId', bundleId)
            // verify required parameter 'toolId' is not null or undefined
            assertParamExists('linkToolToBundle', 'toolId', toolId)
            const localVarPath = `/api/bundles/{bundleId}/tools/{toolId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"toolId"}}`, encodeURIComponent(String(toolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId 
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkToolFromBundle: async (bundleId: string, toolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('unlinkToolFromBundle', 'bundleId', bundleId)
            // verify required parameter 'toolId' is not null or undefined
            assertParamExists('unlinkToolFromBundle', 'toolId', toolId)
            const localVarPath = `/api/bundles/{bundleId}/tools/{toolId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)))
                .replace(`{${"toolId"}}`, encodeURIComponent(String(toolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleToolApi - functional programming interface
 * @export
 */
export const BundleToolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundleToolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleTools(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleToolsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleTools(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolsEligibleForLinkingToBundle(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CwlToolDefinitionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolsEligibleForLinkingToBundle(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkToolToBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkToolToBundle(bundleId, toolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId 
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkToolFromBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkToolFromBundle(bundleId, toolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundleToolApi - factory interface
 * @export
 */
export const BundleToolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundleToolApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of bundle tools.
         * @param {string} bundleId The ID of the bundle to get tools from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTools(bundleId: string, options?: any): AxiosPromise<BundleToolsList> {
            return localVarFp.getBundleTools(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of tools eligible for linking to the bundle.
         * @param {string} bundleId The ID of the bundle to get the eligible tools for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolsEligibleForLinkingToBundle(bundleId: string, options?: any): AxiosPromise<CwlToolDefinitionList> {
            return localVarFp.getToolsEligibleForLinkingToBundle(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a tool to a bundle
         * @param {string} bundleId The ID of the bundle to link the tool to
         * @param {string} toolId The ID of the tool to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkToolToBundle(bundleId: string, toolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkToolToBundle(bundleId, toolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a tool from this bundle.
         * @param {string} bundleId 
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkToolFromBundle(bundleId: string, toolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkToolFromBundle(bundleId, toolId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleToolApi - object-oriented interface
 * @export
 * @class BundleToolApi
 * @extends {BaseAPI}
 */
export class BundleToolApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of bundle tools.
     * @param {string} bundleId The ID of the bundle to get tools from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    public getBundleTools(bundleId: string, options?: AxiosRequestConfig) {
        return BundleToolApiFp(this.configuration).getBundleTools(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of tools eligible for linking to the bundle.
     * @param {string} bundleId The ID of the bundle to get the eligible tools for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    public getToolsEligibleForLinkingToBundle(bundleId: string, options?: AxiosRequestConfig) {
        return BundleToolApiFp(this.configuration).getToolsEligibleForLinkingToBundle(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a tool to a bundle
     * @param {string} bundleId The ID of the bundle to link the tool to
     * @param {string} toolId The ID of the tool to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    public linkToolToBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig) {
        return BundleToolApiFp(this.configuration).linkToolToBundle(bundleId, toolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a tool from this bundle.
     * @param {string} bundleId 
     * @param {string} toolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleToolApi
     */
    public unlinkToolFromBundle(bundleId: string, toolId: string, options?: AxiosRequestConfig) {
        return BundleToolApiFp(this.configuration).unlinkToolFromBundle(bundleId, toolId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('cancelConnector', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}:cancel`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: async (createConnector?: CreateConnector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a download rule.
         * @param {string} connectorId 
         * @param {CreateDownloadRule} [createDownloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadRule: async (connectorId: string, createDownloadRule?: CreateDownloadRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('createDownloadRule', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}/downloadRules`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDownloadRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an upload rule.
         * @param {string} connectorId 
         * @param {CreateUploadRule} [createUploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadRule: async (connectorId: string, createUploadRule?: CreateUploadRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('createUploadRule', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}/uploadRules`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUploadRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDownloadRule: async (connectorId: string, downloadRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('deleteDownloadRule', 'connectorId', connectorId)
            // verify required parameter 'downloadRuleId' is not null or undefined
            assertParamExists('deleteDownloadRule', 'downloadRuleId', downloadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/downloadRules/{downloadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"downloadRuleId"}}`, encodeURIComponent(String(downloadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadRule: async (connectorId: string, uploadRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('deleteUploadRule', 'connectorId', connectorId)
            // verify required parameter 'uploadRuleId' is not null or undefined
            assertParamExists('deleteUploadRule', 'uploadRuleId', uploadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/uploadRules/{uploadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"uploadRuleId"}}`, encodeURIComponent(String(uploadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('disableConnector', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}:disable`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('enableConnector', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}:enable`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getConnector', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors: async (activeOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRule: async (connectorId: string, downloadRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getDownloadRule', 'connectorId', connectorId)
            // verify required parameter 'downloadRuleId' is not null or undefined
            assertParamExists('getDownloadRule', 'downloadRuleId', downloadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/downloadRules/{downloadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"downloadRuleId"}}`, encodeURIComponent(String(downloadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRules: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getDownloadRules', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}/downloadRules`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRule: async (connectorId: string, uploadRuleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getUploadRule', 'connectorId', connectorId)
            // verify required parameter 'uploadRuleId' is not null or undefined
            assertParamExists('getUploadRule', 'uploadRuleId', uploadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/uploadRules/{uploadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"uploadRuleId"}}`, encodeURIComponent(String(uploadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRules: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('getUploadRules', 'connectorId', connectorId)
            const localVarPath = `/api/connectors/{connectorId}/uploadRules`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDownloadRule: async (connectorId: string, downloadRuleId: string, ifMatch?: string, downloadRule?: DownloadRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('updateDownloadRule', 'connectorId', connectorId)
            // verify required parameter 'downloadRuleId' is not null or undefined
            assertParamExists('updateDownloadRule', 'downloadRuleId', downloadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/downloadRules/{downloadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"downloadRuleId"}}`, encodeURIComponent(String(downloadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat 
         * @summary Update an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUploadRule: async (connectorId: string, uploadRuleId: string, ifMatch?: string, uploadRule?: UploadRule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('updateUploadRule', 'connectorId', connectorId)
            // verify required parameter 'uploadRuleId' is not null or undefined
            assertParamExists('updateUploadRule', 'uploadRuleId', uploadRuleId)
            const localVarPath = `/api/connectors/{connectorId}/uploadRules/{uploadRuleId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)))
                .replace(`{${"uploadRuleId"}}`, encodeURIComponent(String(uploadRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnector(createConnector?: CreateConnector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnector(createConnector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a download rule.
         * @param {string} connectorId 
         * @param {CreateDownloadRule} [createDownloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDownloadRule(connectorId, createDownloadRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an upload rule.
         * @param {string} connectorId 
         * @param {CreateUploadRule} [createUploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadRule(connectorId, createUploadRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDownloadRule(connectorId, downloadRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUploadRule(connectorId, uploadRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectors(activeOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectors(activeOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadRule(connectorId, downloadRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownloadRules(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadRuleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadRules(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadRule(connectorId, uploadRuleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadRules(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRuleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadRules(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string, downloadRule?: DownloadRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat 
         * @summary Update an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string, uploadRule?: UploadRule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Cancel a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelConnector(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a connector.
         * @param {CreateConnector} [createConnector] The connector to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector(createConnector?: CreateConnector, options?: any): AxiosPromise<Connector> {
            return localVarFp.createConnector(createConnector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a download rule.
         * @param {string} connectorId 
         * @param {CreateDownloadRule} [createDownloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule, options?: any): AxiosPromise<DownloadRule> {
            return localVarFp.createDownloadRule(connectorId, createDownloadRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an upload rule.
         * @param {string} connectorId 
         * @param {CreateUploadRule} [createUploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule, options?: any): AxiosPromise<UploadRule> {
            return localVarFp.createUploadRule(connectorId, createUploadRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDownloadRule(connectorId, downloadRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUploadRule(connectorId: string, uploadRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUploadRule(connectorId, uploadRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Disable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.disableConnector(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Enable a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.enableConnector(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a connector.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(connectorId: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.getConnector(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of connectors.
         * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(activeOnly?: boolean, options?: any): AxiosPromise<ConnectorList> {
            return localVarFp.getConnectors(activeOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRule(connectorId: string, downloadRuleId: string, options?: any): AxiosPromise<DownloadRule> {
            return localVarFp.getDownloadRule(connectorId, downloadRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of download rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownloadRules(connectorId: string, options?: any): AxiosPromise<DownloadRuleList> {
            return localVarFp.getDownloadRules(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRule(connectorId: string, uploadRuleId: string, options?: any): AxiosPromise<UploadRule> {
            return localVarFp.getUploadRule(connectorId, uploadRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of upload rules.
         * @param {string} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadRules(connectorId: string, options?: any): AxiosPromise<UploadRuleList> {
            return localVarFp.getUploadRules(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
         * @summary Update a download rule.
         * @param {string} connectorId 
         * @param {string} downloadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {DownloadRule} [downloadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string, downloadRule?: DownloadRule, options?: any): AxiosPromise<DownloadRule> {
            return localVarFp.updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat 
         * @summary Update an upload rule.
         * @param {string} connectorId 
         * @param {string} uploadRuleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {UploadRule} [uploadRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string, uploadRule?: UploadRule, options?: any): AxiosPromise<UploadRule> {
            return localVarFp.updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * Endpoint for cancelling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Cancel a connector.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public cancelConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).cancelConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a connector.
     * @param {CreateConnector} [createConnector] The connector to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public createConnector(createConnector?: CreateConnector, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).createConnector(createConnector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a download rule.
     * @param {string} connectorId 
     * @param {CreateDownloadRule} [createDownloadRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public createDownloadRule(connectorId: string, createDownloadRule?: CreateDownloadRule, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).createDownloadRule(connectorId, createDownloadRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an upload rule.
     * @param {string} connectorId 
     * @param {CreateUploadRule} [createUploadRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public createUploadRule(connectorId: string, createUploadRule?: CreateUploadRule, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).createUploadRule(connectorId, createUploadRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a download rule.
     * @param {string} connectorId 
     * @param {string} downloadRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public deleteDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).deleteDownloadRule(connectorId, downloadRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an upload rule.
     * @param {string} connectorId 
     * @param {string} uploadRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public deleteUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).deleteUploadRule(connectorId, uploadRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for disabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Disable a connector.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public disableConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).disableConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for enabling a connector. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Enable a connector.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public enableConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).enableConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a connector.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of connectors.
     * @param {boolean} [activeOnly] When true only the active connectors will be returned. When false (default value) all connectors wil be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getConnectors(activeOnly?: boolean, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getConnectors(activeOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a download rule.
     * @param {string} connectorId 
     * @param {string} downloadRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getDownloadRule(connectorId: string, downloadRuleId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getDownloadRule(connectorId, downloadRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of download rules.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getDownloadRules(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getDownloadRules(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an upload rule.
     * @param {string} connectorId 
     * @param {string} uploadRuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getUploadRule(connectorId: string, uploadRuleId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getUploadRule(connectorId, uploadRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of upload rules.
     * @param {string} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public getUploadRules(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).getUploadRules(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated:  - code  - active  - description  - sequence  - formatCode  - projectName  - targetLocalFolder  - protocol  - fileNameExpression  - disableHashing
     * @summary Update a download rule.
     * @param {string} connectorId 
     * @param {string} downloadRuleId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {DownloadRule} [downloadRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public updateDownloadRule(connectorId: string, downloadRuleId: string, ifMatch?: string, downloadRule?: DownloadRule, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).updateDownloadRule(connectorId, downloadRuleId, ifMatch, downloadRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated:  - code  - active  - description  - localFolder  - filePattern  - dataFormat 
     * @summary Update an upload rule.
     * @param {string} connectorId 
     * @param {string} uploadRuleId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {UploadRule} [uploadRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public updateUploadRule(connectorId: string, uploadRuleId: string, ifMatch?: string, uploadRule?: UploadRule, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).updateUploadRule(connectorId, uploadRuleId, ifMatch, uploadRule, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataFormatApi - axios parameter creator
 * @export
 */
export const DataFormatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFormats: async (pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dataFormats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataFormatApi - functional programming interface
 * @export
 */
export const DataFormatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataFormatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataFormats(pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataFormatPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataFormats(pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataFormatApi - factory interface
 * @export
 */
export const DataFormatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataFormatApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of data formats.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataFormats(pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<DataFormatPagedList> {
            return localVarFp.getDataFormats(pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataFormatApi - object-oriented interface
 * @export
 * @class DataFormatApi
 * @extends {BaseAPI}
 */
export class DataFormatApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of data formats.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataFormatApi
     */
    public getDataFormats(pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return DataFormatApiFp(this.configuration).getDataFormats(pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EntitlementDetailApi - axios parameter creator
 * @export
 */
export const EntitlementDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForCwl: async (searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activationCodes:findAllMatchingForCwl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchMatchingActivationCodesForCwlAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForNextflow: async (searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activationCodes:findAllMatchingForNextflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchMatchingActivationCodesForNextflowAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodeForCwl: async (searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activationCodes:findBestMatchingForCwl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchMatchingActivationCodesForCwlAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodesForNextflow: async (searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/activationCodes:findBestMatchingForNextflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchMatchingActivationCodesForNextflowAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitlementDetailApi - functional programming interface
 * @export
 */
export const EntitlementDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitlementDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationCodeDetailList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationCodeDetailList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationCodeDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivationCodeDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EntitlementDetailApi - factory interface
 * @export
 */
export const EntitlementDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitlementDetailApiFp(configuration)
    return {
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: any): AxiosPromise<ActivationCodeDetailList> {
            return localVarFp.findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search all matching activation code details for a Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: any): AxiosPromise<ActivationCodeDetailList> {
            return localVarFp.findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code detail for Cwl pipeline.
         * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: any): AxiosPromise<ActivationCodeDetail> {
            return localVarFp.findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Search the best matching activation code details for Nextflow pipeline.
         * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: any): AxiosPromise<ActivationCodeDetail> {
            return localVarFp.findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitlementDetailApi - object-oriented interface
 * @export
 * @class EntitlementDetailApi
 * @extends {BaseAPI}
 */
export class EntitlementDetailApi extends BaseAPI {
    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    public findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig) {
        return EntitlementDetailApiFp(this.configuration).findAllMatchingActivationCodesForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for searching all matching activation code details for a project and an analysis from a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search all matching activation code details for a Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    public findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig) {
        return EntitlementDetailApiFp(this.configuration).findAllMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for searching the best activation code detail for a project and an analysis from a Cwl pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code detail for Cwl pipeline.
     * @param {SearchMatchingActivationCodesForCwlAnalysis} [searchMatchingActivationCodesForCwlAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    public findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis?: SearchMatchingActivationCodesForCwlAnalysis, options?: AxiosRequestConfig) {
        return EntitlementDetailApiFp(this.configuration).findBestMatchingActivationCodeForCwl(searchMatchingActivationCodesForCwlAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for searching the best activation code details for a project and an analysis for a Nextflow pipeline.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Search the best matching activation code details for Nextflow pipeline.
     * @param {SearchMatchingActivationCodesForNextflowAnalysis} [searchMatchingActivationCodesForNextflowAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitlementDetailApi
     */
    public findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis?: SearchMatchingActivationCodesForNextflowAnalysis, options?: AxiosRequestConfig) {
        return EntitlementDetailApiFp(this.configuration).findBestMatchingActivationCodesForNextflow(searchMatchingActivationCodesForNextflowAnalysis, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventCodeApi - axios parameter creator
 * @export
 */
export const EventCodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventCodes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/eventCodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventCodeApi - functional programming interface
 * @export
 */
export const EventCodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventCodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventCodes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventCodeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventCodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventCodeApi - factory interface
 * @export
 */
export const EventCodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventCodeApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve event codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventCodes(options?: any): AxiosPromise<EventCodeList> {
            return localVarFp.getEventCodes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventCodeApi - object-oriented interface
 * @export
 * @class EventCodeApi
 * @extends {BaseAPI}
 */
export class EventCodeApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve event codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCodeApi
     */
    public getEventCodes(options?: AxiosRequestConfig) {
        return EventCodeApiFp(this.configuration).getEventCodes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventLogApi - axios parameter creator
 * @export
 */
export const EventLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLogs: async (code?: string, codeFilterType?: 'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS', category?: 'ERROR' | 'WARN' | 'INFO', dateFrom?: string, dateUntil?: string, rows?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/eventLog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (codeFilterType !== undefined) {
                localVarQueryParameter['codeFilterType'] = codeFilterType;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateUntil !== undefined) {
                localVarQueryParameter['dateUntil'] = dateUntil;
            }

            if (rows !== undefined) {
                localVarQueryParameter['rows'] = rows;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventLogApi - functional programming interface
 * @export
 */
export const EventLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventLogs(code?: string, codeFilterType?: 'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS', category?: 'ERROR' | 'WARN' | 'INFO', dateFrom?: string, dateUntil?: string, rows?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventLogApi - factory interface
 * @export
 */
export const EventLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventLogApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of event logs.
         * @param {string} [code] Code
         * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
         * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
         * @param {string} [dateFrom] Date from
         * @param {string} [dateUntil] Date until
         * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventLogs(code?: string, codeFilterType?: 'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS', category?: 'ERROR' | 'WARN' | 'INFO', dateFrom?: string, dateUntil?: string, rows?: number, options?: any): AxiosPromise<EventLogList> {
            return localVarFp.getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventLogApi - object-oriented interface
 * @export
 * @class EventLogApi
 * @extends {BaseAPI}
 */
export class EventLogApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of event logs.
     * @param {string} [code] Code
     * @param {'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS'} [codeFilterType] Code filter type
     * @param {'ERROR' | 'WARN' | 'INFO'} [category] Category
     * @param {string} [dateFrom] Date from
     * @param {string} [dateUntil] Date until
     * @param {number} [rows] Amount of rows to fetch. Maximum 250. Defaults to 250
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventLogApi
     */
    public getEventLogs(code?: string, codeFilterType?: 'STARTS_WITH' | 'ENDS_WITH' | 'EQUALS', category?: 'ERROR' | 'WARN' | 'INFO', dateFrom?: string, dateUntil?: string, rows?: number, options?: AxiosRequestConfig) {
        return EventLogApiFp(this.configuration).getEventLogs(code, codeFilterType, category, dateFrom, dateUntil, rows, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataModelApi - axios parameter creator
 * @export
 */
export const MetadataModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModel: async (metadataModelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataModelId' is not null or undefined
            assertParamExists('getMetadataModel', 'metadataModelId', metadataModelId)
            const localVarPath = `/api/metadataModels/{metadataModelId}`
                .replace(`{${"metadataModelId"}}`, encodeURIComponent(String(metadataModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModelFields: async (metadataModelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataModelId' is not null or undefined
            assertParamExists('getMetadataModelFields', 'metadataModelId', metadataModelId)
            const localVarPath = `/api/metadataModels/{metadataModelId}/fields`
                .replace(`{${"metadataModelId"}}`, encodeURIComponent(String(metadataModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metadataModels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantModel: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metadataModels/tenantModel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataModelApi - functional programming interface
 * @export
 */
export const MetadataModelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataModelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataModel(metadataModelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataModel(metadataModelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataModelFields(metadataModelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FieldList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataModelFields(metadataModelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataModels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataModelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataModels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantModel(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantModel(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataModelApi - factory interface
 * @export
 */
export const MetadataModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataModelApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModel(metadataModelId: string, options?: any): AxiosPromise<MetadataModel> {
            return localVarFp.getMetadataModel(metadataModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
         * @param {string} metadataModelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModelFields(metadataModelId: string, options?: any): AxiosPromise<FieldList> {
            return localVarFp.getMetadataModelFields(metadataModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
         * @summary Retrieve the metadata models for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataModels(options?: any): AxiosPromise<MetadataModelList> {
            return localVarFp.getMetadataModels(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
         * @summary Retrieve the tenant model for the tenant associated to the security context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantModel(options?: any): AxiosPromise<Model> {
            return localVarFp.getTenantModel(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataModelApi - object-oriented interface
 * @export
 * @class MetadataModelApi
 * @extends {BaseAPI}
 */
export class MetadataModelApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    public getMetadataModel(metadataModelId: string, options?: AxiosRequestConfig) {
        return MetadataModelApiFp(this.configuration).getMetadataModel(metadataModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the fields of a metadata model. Only metadata models that the user has access to can be retrieved.
     * @param {string} metadataModelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    public getMetadataModelFields(metadataModelId: string, options?: AxiosRequestConfig) {
        return MetadataModelApiFp(this.configuration).getMetadataModelFields(metadataModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the metadata models for the tenant associated to the security context. This call returns a list of metadata models for the tenant in a non-hierarchical way. Instead of a model having a list of child models all models except the root model have a parent model identifier. This can be used to reconstruct the hierarchy.
     * @summary Retrieve the metadata models for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    public getMetadataModels(options?: AxiosRequestConfig) {
        return MetadataModelApiFp(this.configuration).getMetadataModels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the tenant model for the tenant associated to the security context. The tenant model is a hierarchical structure where the top level tenant holds a list of child models (which in turn can hold child models).
     * @summary Retrieve the tenant model for the tenant associated to the security context.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataModelApi
     */
    public getTenantModel(options?: AxiosRequestConfig) {
        return MetadataModelApiFp(this.configuration).getTenantModel(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationChannelApi - axios parameter creator
 * @export
 */
export const NotificationChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationChannel: async (createNotificationChannel?: CreateNotificationChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notificationChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationChannel: async (channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('deleteNotificationChannel', 'channelId', channelId)
            const localVarPath = `/api/notificationChannels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannel: async (channelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('getNotificationChannel', 'channelId', channelId)
            const localVarPath = `/api/notificationChannels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notificationChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address 
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationChannel: async (channelId: string, ifMatch?: string, notificationChannel?: NotificationChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('updateNotificationChannel', 'channelId', channelId)
            const localVarPath = `/api/notificationChannels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationChannelApi - functional programming interface
 * @export
 */
export const NotificationChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationChannel(createNotificationChannel?: CreateNotificationChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationChannel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationChannel(createNotificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationChannel(channelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationChannel(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationChannel(channelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationChannel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationChannel(channelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationChannels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationChannelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationChannels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address 
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationChannel(channelId: string, ifMatch?: string, notificationChannel?: NotificationChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationChannel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationChannel(channelId, ifMatch, notificationChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationChannelApi - factory interface
 * @export
 */
export const NotificationChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a notification channel
         * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationChannel(createNotificationChannel?: CreateNotificationChannel, options?: any): AxiosPromise<NotificationChannel> {
            return localVarFp.createNotificationChannel(createNotificationChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a notification channel
         * @param {string} channelId The ID of the notification channel to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationChannel(channelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotificationChannel(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a notification channel
         * @param {string} channelId The ID of the notification channel to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannel(channelId: string, options?: any): AxiosPromise<NotificationChannel> {
            return localVarFp.getNotificationChannel(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve notification channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationChannels(options?: any): AxiosPromise<NotificationChannelList> {
            return localVarFp.getNotificationChannels(options).then((request) => request(axios, basePath));
        },
        /**
         * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address 
         * @summary Update a notification channel
         * @param {string} channelId The ID of the notification channel to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationChannel} [notificationChannel] The updated channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationChannel(channelId: string, ifMatch?: string, notificationChannel?: NotificationChannel, options?: any): AxiosPromise<NotificationChannel> {
            return localVarFp.updateNotificationChannel(channelId, ifMatch, notificationChannel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationChannelApi - object-oriented interface
 * @export
 * @class NotificationChannelApi
 * @extends {BaseAPI}
 */
export class NotificationChannelApi extends BaseAPI {
    /**
     * 
     * @summary Create a notification channel
     * @param {CreateNotificationChannel} [createNotificationChannel] The new channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    public createNotificationChannel(createNotificationChannel?: CreateNotificationChannel, options?: AxiosRequestConfig) {
        return NotificationChannelApiFp(this.configuration).createNotificationChannel(createNotificationChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a notification channel
     * @param {string} channelId The ID of the notification channel to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    public deleteNotificationChannel(channelId: string, options?: AxiosRequestConfig) {
        return NotificationChannelApiFp(this.configuration).deleteNotificationChannel(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a notification channel
     * @param {string} channelId The ID of the notification channel to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    public getNotificationChannel(channelId: string, options?: AxiosRequestConfig) {
        return NotificationChannelApiFp(this.configuration).getNotificationChannel(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve notification channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    public getNotificationChannels(options?: AxiosRequestConfig) {
        return NotificationChannelApiFp(this.configuration).getNotificationChannels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will affect all subscriptions which use this address!Fields which can be updated:  - enabled  - address 
     * @summary Update a notification channel
     * @param {string} channelId The ID of the notification channel to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationChannel} [notificationChannel] The updated channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelApi
     */
    public updateNotificationChannel(channelId: string, ifMatch?: string, notificationChannel?: NotificationChannel, options?: AxiosRequestConfig) {
        return NotificationChannelApiFp(this.configuration).updateNotificationChannel(channelId, ifMatch, notificationChannel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelineApi - axios parameter creator
 * @export
 */
export const PipelineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipeline', 'pipelineId', pipelineId)
            const localVarPath = `/api/pipelines/{pipelineId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineInputParameters: async (pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineInputParameters', 'pipelineId', pipelineId)
            const localVarPath = `/api/pipelines/{pipelineId}/inputParameters`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineReferenceSets: async (pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineReferenceSets', 'pipelineId', pipelineId)
            const localVarPath = `/api/pipelines/{pipelineId}/referenceSets`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineApi - functional programming interface
 * @export
 */
export const PipelineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineInputParameters(pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InputParameterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineInputParameters(pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineReferenceSets(pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceSetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineReferenceSets(pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelines(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelines(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelineApi - factory interface
 * @export
 */
export const PipelineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(pipelineId: string, options?: any): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve input parameters for a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineInputParameters(pipelineId: string, options?: any): AxiosPromise<InputParameterList> {
            return localVarFp.getPipelineInputParameters(pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the reference sets of a pipeline.
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineReferenceSets(pipelineId: string, options?: any): AxiosPromise<ReferenceSetList> {
            return localVarFp.getPipelineReferenceSets(pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of pipelines.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelines(options?: any): AxiosPromise<PipelineList> {
            return localVarFp.getPipelines(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PipelineApi - object-oriented interface
 * @export
 * @class PipelineApi
 * @extends {BaseAPI}
 */
export class PipelineApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public getPipeline(pipelineId: string, options?: AxiosRequestConfig) {
        return PipelineApiFp(this.configuration).getPipeline(pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve input parameters for a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public getPipelineInputParameters(pipelineId: string, options?: AxiosRequestConfig) {
        return PipelineApiFp(this.configuration).getPipelineInputParameters(pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the reference sets of a pipeline.
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public getPipelineReferenceSets(pipelineId: string, options?: AxiosRequestConfig) {
        return PipelineApiFp(this.configuration).getPipelineReferenceSets(pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of pipelines.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApi
     */
    public getPipelines(options?: AxiosRequestConfig) {
        return PipelineApiFp(this.configuration).getPipelines(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new project.
         * @param {CreateProject} [createProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (createProject?: CreateProject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (search?: string, userTags?: Array<string>, technicalTags?: Array<string>, includeHiddenProjects?: boolean, region?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userTags) {
                localVarQueryParameter['userTags'] = userTags;
            }

            if (technicalTags) {
                localVarQueryParameter['technicalTags'] = technicalTags;
            }

            if (includeHiddenProjects !== undefined) {
                localVarQueryParameter['includeHiddenProjects'] = includeHiddenProjects;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: string, ifMatch?: string, project?: Project, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new project.
         * @param {CreateProject} [createProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(createProject?: CreateProject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(createProject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(search?: string, userTags?: Array<string>, technicalTags?: Array<string>, includeHiddenProjects?: boolean, region?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: string, ifMatch?: string, project?: Project, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, ifMatch, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new project.
         * @param {CreateProject} [createProject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(createProject?: CreateProject, options?: any): AxiosPromise<Project> {
            return localVarFp.createProject(createProject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a project.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of projects.
         * @param {string} [search] Search
         * @param {Array<string>} [userTags] User tags to filter on
         * @param {Array<string>} [technicalTags] Technical tags to filter on
         * @param {boolean} [includeHiddenProjects] Include hidden projects.
         * @param {string} [region] The ID of the region to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(search?: string, userTags?: Array<string>, technicalTags?: Array<string>, includeHiddenProjects?: boolean, region?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<ProjectPagedList> {
            return localVarFp.getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
         * @summary Update a project.
         * @param {string} projectId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: string, ifMatch?: string, project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.updateProject(projectId, ifMatch, project, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Create a new project.
     * @param {CreateProject} [createProject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public createProject(createProject?: CreateProject, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).createProject(createProject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a project.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getProject(projectId: string, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of projects.
     * @param {string} [search] Search
     * @param {Array<string>} [userTags] User tags to filter on
     * @param {Array<string>} [technicalTags] Technical tags to filter on
     * @param {boolean} [includeHiddenProjects] Include hidden projects.
     * @param {string} [region] The ID of the region to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - name - shortDescription - information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getProjects(search?: string, userTags?: Array<string>, technicalTags?: Array<string>, includeHiddenProjects?: boolean, region?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).getProjects(search, userTags, technicalTags, includeHiddenProjects, region, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated: - shortDescription - projectInformation - billingMode - dataSharingEnabled - tags - storageBundle - metaDataModel
     * @summary Update a project.
     * @param {string} projectId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateProject(projectId: string, ifMatch?: string, project?: Project, options?: AxiosRequestConfig) {
        return ProjectApiFp(this.configuration).updateProject(projectId, ifMatch, project, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectAnalysisApi - axios parameter creator
 * @export
 */
export const ProjectAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortAnalysis: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('abortAnalysis', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('abortAnalysis', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}:abort`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId 
         * @param {CreateCwlAnalysis} createCwlAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlAnalysis: async (projectId: string, createCwlAnalysis: CreateCwlAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCwlAnalysis', 'projectId', projectId)
            // verify required parameter 'createCwlAnalysis' is not null or undefined
            assertParamExists('createCwlAnalysis', 'createCwlAnalysis', createCwlAnalysis)
            const localVarPath = `/api/projects/{projectId}/analysis:cwl`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCwlAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId 
         * @param {CreateNextflowAnalysis} createNextflowAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowAnalysis: async (projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNextflowAnalysis', 'projectId', projectId)
            // verify required parameter 'createNextflowAnalysis' is not null or undefined
            assertParamExists('createNextflowAnalysis', 'createNextflowAnalysis', createNextflowAnalysis)
            const localVarPath = `/api/projects/{projectId}/analysis:nextflow`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNextflowAnalysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId 
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyses: async (projectId: string, reference?: string, userreference?: string, status?: string, usertag?: string, technicaltag?: string, referencetag?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalyses', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/analyses`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (userreference !== undefined) {
                localVarQueryParameter['userreference'] = userreference;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (usertag !== undefined) {
                localVarQueryParameter['usertag'] = usertag;
            }

            if (technicaltag !== undefined) {
                localVarQueryParameter['technicaltag'] = technicaltag;
            }

            if (referencetag !== undefined) {
                localVarQueryParameter['referencetag'] = referencetag;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalysis', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('getAnalysis', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisConfigurations: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalysisConfigurations', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('getAnalysisConfigurations', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}/configurations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisInputs: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalysisInputs', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('getAnalysisInputs', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}/inputs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisOutputs: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalysisOutputs', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('getAnalysisOutputs', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}/outputs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisSteps: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalysisSteps', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('getAnalysisSteps', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}/steps`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hGetExecutionOutputObject: async (projectId: string, analysisId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('hGetExecutionOutputObject', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('hGetExecutionOutputObject', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}/rawOutput`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId 
         * @param {string} analysisId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysis: async (projectId: string, analysisId: string, ifMatch?: string, analysis?: Analysis, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateAnalysis', 'projectId', projectId)
            // verify required parameter 'analysisId' is not null or undefined
            assertParamExists('updateAnalysis', 'analysisId', analysisId)
            const localVarPath = `/api/projects/{projectId}/analyses/{analysisId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"analysisId"}}`, encodeURIComponent(String(analysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectAnalysisApi - functional programming interface
 * @export
 */
export const ProjectAnalysisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectAnalysisApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abortAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abortAnalysis(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId 
         * @param {CreateCwlAnalysis} createCwlAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCwlAnalysis(projectId, createCwlAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId 
         * @param {CreateNextflowAnalysis} createNextflowAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNextflowAnalysis(projectId, createNextflowAnalysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId 
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyses(projectId: string, reference?: string, userreference?: string, status?: string, usertag?: string, technicaltag?: string, referencetag?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysis(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisConfigurations(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionConfigurationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisConfigurations(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisInputs(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisInputList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisInputs(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisOutputs(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisOutputList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisOutputs(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalysisSteps(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisStepList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalysisSteps(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hGetExecutionOutputObject(projectId: string, analysisId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisRawOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hGetExecutionOutputObject(projectId, analysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId 
         * @param {string} analysisId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnalysis(projectId: string, analysisId: string, ifMatch?: string, analysis?: Analysis, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnalysis(projectId, analysisId, ifMatch, analysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectAnalysisApi - factory interface
 * @export
 */
export const ProjectAnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectAnalysisApiFp(configuration)
    return {
        /**
         * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to abort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortAnalysis(projectId: string, analysisId: string, options?: any): AxiosPromise<void> {
            return localVarFp.abortAnalysis(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and start an analysis for a CWL pipeline.
         * @param {string} projectId 
         * @param {CreateCwlAnalysis} createCwlAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: any): AxiosPromise<Analysis> {
            return localVarFp.createCwlAnalysis(projectId, createCwlAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create and start an analysis for a Nextflow pipeline.
         * @param {string} projectId 
         * @param {CreateNextflowAnalysis} createNextflowAnalysis 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: any): AxiosPromise<Analysis> {
            return localVarFp.createNextflowAnalysis(projectId, createNextflowAnalysis, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of project analyses.
         * @param {string} projectId 
         * @param {string} [reference] The reference to filter on.
         * @param {string} [userreference] The user-reference to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [usertag] The user-tags to filter on.
         * @param {string} [technicaltag] The technical-tags to filter on.
         * @param {string} [referencetag] The reference-data-tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyses(projectId: string, reference?: string, userreference?: string, status?: string, usertag?: string, technicaltag?: string, referencetag?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<AnalysisPagedList> {
            return localVarFp.getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysis(projectId: string, analysisId: string, options?: any): AxiosPromise<Analysis> {
            return localVarFp.getAnalysis(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the configurations of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the configuration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisConfigurations(projectId: string, analysisId: string, options?: any): AxiosPromise<ExecutionConfigurationList> {
            return localVarFp.getAnalysisConfigurations(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the inputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the inputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisInputs(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisInputList> {
            return localVarFp.getAnalysisInputs(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the outputs of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the outputs for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisOutputs(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisOutputList> {
            return localVarFp.getAnalysisOutputs(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the individual steps of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalysisSteps(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisStepList> {
            return localVarFp.getAnalysisSteps(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the raw output of an analysis.
         * @param {string} projectId 
         * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hGetExecutionOutputObject(projectId: string, analysisId: string, options?: any): AxiosPromise<AnalysisRawOutput> {
            return localVarFp.hGetExecutionOutputObject(projectId, analysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attributes which can be updated:    - tags
         * @summary Update an analysis.
         * @param {string} projectId 
         * @param {string} analysisId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnalysis(projectId: string, analysisId: string, ifMatch?: string, analysis?: Analysis, options?: any): AxiosPromise<Analysis> {
            return localVarFp.updateAnalysis(projectId, analysisId, ifMatch, analysis, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectAnalysisApi - object-oriented interface
 * @export
 * @class ProjectAnalysisApi
 * @extends {BaseAPI}
 */
export class ProjectAnalysisApi extends BaseAPI {
    /**
     * Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to abort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public abortAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).abortAnalysis(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and start an analysis for a CWL pipeline.
     * @param {string} projectId 
     * @param {CreateCwlAnalysis} createCwlAnalysis 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public createCwlAnalysis(projectId: string, createCwlAnalysis: CreateCwlAnalysis, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).createCwlAnalysis(projectId, createCwlAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create and start an analysis for a Nextflow pipeline.
     * @param {string} projectId 
     * @param {CreateNextflowAnalysis} createNextflowAnalysis 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public createNextflowAnalysis(projectId: string, createNextflowAnalysis: CreateNextflowAnalysis, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).createNextflowAnalysis(projectId, createNextflowAnalysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of project analyses.
     * @param {string} projectId 
     * @param {string} [reference] The reference to filter on.
     * @param {string} [userreference] The user-reference to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [usertag] The user-tags to filter on.
     * @param {string} [technicaltag] The technical-tags to filter on.
     * @param {string} [referencetag] The reference-data-tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalyses(projectId: string, reference?: string, userreference?: string, status?: string, usertag?: string, technicaltag?: string, referencetag?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalyses(projectId, reference, userreference, status, usertag, technicaltag, referencetag, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalysis(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalysis(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the configurations of an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to retrieve the configuration for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalysisConfigurations(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalysisConfigurations(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the inputs of an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to retrieve the inputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalysisInputs(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalysisInputs(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the outputs of an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to retrieve the outputs for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalysisOutputs(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalysisOutputs(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the individual steps of an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis to retrieve the individual steps for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public getAnalysisSteps(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).getAnalysisSteps(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the raw output of an analysis.
     * @param {string} projectId 
     * @param {string} analysisId The ID of the analysis for which to retrieve the raw output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public hGetExecutionOutputObject(projectId: string, analysisId: string, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).hGetExecutionOutputObject(projectId, analysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attributes which can be updated:    - tags
     * @summary Update an analysis.
     * @param {string} projectId 
     * @param {string} analysisId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {Analysis} [analysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectAnalysisApi
     */
    public updateAnalysis(projectId: string, analysisId: string, ifMatch?: string, analysis?: Analysis, options?: AxiosRequestConfig) {
        return ProjectAnalysisApiFp(this.configuration).updateAnalysis(projectId, analysisId, ifMatch, analysis, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectBaseApi - axios parameter creator
 * @export
 */
export const ProjectBaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBaseConnectionDetails: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createBaseConnectionDetails', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/base:connectionDetails`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectBaseApi - functional programming interface
 * @export
 */
export const ProjectBaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectBaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBaseConnectionDetails(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseConnection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBaseConnectionDetails(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectBaseApi - factory interface
 * @export
 */
export const ProjectBaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectBaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates the connection details to snowflake instance.
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBaseConnectionDetails(projectId: string, options?: any): AxiosPromise<BaseConnection> {
            return localVarFp.createBaseConnectionDetails(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectBaseApi - object-oriented interface
 * @export
 * @class ProjectBaseApi
 * @extends {BaseAPI}
 */
export class ProjectBaseApi extends BaseAPI {
    /**
     * 
     * @summary Creates the connection details to snowflake instance.
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseApi
     */
    public createBaseConnectionDetails(projectId: string, options?: AxiosRequestConfig) {
        return ProjectBaseApiFp(this.configuration).createBaseConnectionDetails(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectBaseJobApi - axios parameter creator
 * @export
 */
export const ProjectBaseJobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a base job.
         * @param {string} projectId 
         * @param {string} baseJobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJob: async (projectId: string, baseJobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getBaseJob', 'projectId', projectId)
            // verify required parameter 'baseJobId' is not null or undefined
            assertParamExists('getBaseJob', 'baseJobId', baseJobId)
            const localVarPath = `/api/projects/{projectId}/base/jobs/{baseJobId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"baseJobId"}}`, encodeURIComponent(String(baseJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of base jobs
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJobs: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getBaseJobs', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/base/jobs`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectBaseJobApi - functional programming interface
 * @export
 */
export const ProjectBaseJobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectBaseJobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a base job.
         * @param {string} projectId 
         * @param {string} baseJobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaseJob(projectId: string, baseJobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBaseJob(projectId, baseJobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of base jobs
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaseJobs(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseJobList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBaseJobs(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectBaseJobApi - factory interface
 * @export
 */
export const ProjectBaseJobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectBaseJobApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a base job.
         * @param {string} projectId 
         * @param {string} baseJobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJob(projectId: string, baseJobId: string, options?: any): AxiosPromise<BaseJob> {
            return localVarFp.getBaseJob(projectId, baseJobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of base jobs
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseJobs(projectId: string, options?: any): AxiosPromise<BaseJobList> {
            return localVarFp.getBaseJobs(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectBaseJobApi - object-oriented interface
 * @export
 * @class ProjectBaseJobApi
 * @extends {BaseAPI}
 */
export class ProjectBaseJobApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a base job.
     * @param {string} projectId 
     * @param {string} baseJobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    public getBaseJob(projectId: string, baseJobId: string, options?: AxiosRequestConfig) {
        return ProjectBaseJobApiFp(this.configuration).getBaseJob(projectId, baseJobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of base jobs
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseJobApi
     */
    public getBaseJobs(projectId: string, options?: AxiosRequestConfig) {
        return ProjectBaseJobApiFp(this.configuration).getBaseJobs(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectBaseTableApi - axios parameter creator
 * @export
 */
export const ProjectBaseTableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseTables: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getBaseTables', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/base/tables`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId 
         * @param {string} tableId 
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadData: async (projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('loadData', 'projectId', projectId)
            // verify required parameter 'tableId' is not null or undefined
            assertParamExists('loadData', 'tableId', tableId)
            const localVarPath = `/api/projects/{projectId}/base/tables/{tableId}:loadData`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tableId"}}`, encodeURIComponent(String(tableId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadDataInBaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectBaseTableApi - functional programming interface
 * @export
 */
export const ProjectBaseTableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectBaseTableApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaseTables(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectBaseTableList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBaseTables(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId 
         * @param {string} tableId 
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadData(projectId, tableId, loadDataInBaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectBaseTableApi - factory interface
 * @export
 */
export const ProjectBaseTableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectBaseTableApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a liste of base tables.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseTables(projectId: string, options?: any): AxiosPromise<ProjectBaseTableList> {
            return localVarFp.getBaseTables(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Load data in the specified table
         * @summary Load data in a base table.
         * @param {string} projectId 
         * @param {string} tableId 
         * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest, options?: any): AxiosPromise<BaseJob> {
            return localVarFp.loadData(projectId, tableId, loadDataInBaseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectBaseTableApi - object-oriented interface
 * @export
 * @class ProjectBaseTableApi
 * @extends {BaseAPI}
 */
export class ProjectBaseTableApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a liste of base tables.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    public getBaseTables(projectId: string, options?: AxiosRequestConfig) {
        return ProjectBaseTableApiFp(this.configuration).getBaseTables(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Load data in the specified table
     * @summary Load data in a base table.
     * @param {string} projectId 
     * @param {string} tableId 
     * @param {LoadDataInBaseRequest} [loadDataInBaseRequest] Load data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectBaseTableApi
     */
    public loadData(projectId: string, tableId: string, loadDataInBaseRequest?: LoadDataInBaseRequest, options?: AxiosRequestConfig) {
        return ProjectBaseTableApiFp(this.configuration).loadData(projectId, tableId, loadDataInBaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectCustomEventsApi - axios parameter creator
 * @export
 */
export const ProjectCustomEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new custom event.
         * @param {string} projectId 
         * @param {CreateCustomEvent} createCustomEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent: async (projectId: string, createCustomEvent: CreateCustomEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCustomEvent', 'projectId', projectId)
            // verify required parameter 'createCustomEvent' is not null or undefined
            assertParamExists('createCustomEvent', 'createCustomEvent', createCustomEvent)
            const localVarPath = `/api/projects/{projectId}/customEvents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectCustomEventsApi - functional programming interface
 * @export
 */
export const ProjectCustomEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectCustomEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new custom event.
         * @param {string} projectId 
         * @param {CreateCustomEvent} createCustomEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomEvent(projectId, createCustomEvent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectCustomEventsApi - factory interface
 * @export
 */
export const ProjectCustomEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectCustomEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new custom event.
         * @param {string} projectId 
         * @param {CreateCustomEvent} createCustomEvent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: any): AxiosPromise<void> {
            return localVarFp.createCustomEvent(projectId, createCustomEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectCustomEventsApi - object-oriented interface
 * @export
 * @class ProjectCustomEventsApi
 * @extends {BaseAPI}
 */
export class ProjectCustomEventsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new custom event.
     * @param {string} projectId 
     * @param {CreateCustomEvent} createCustomEvent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomEventsApi
     */
    public createCustomEvent(projectId: string, createCustomEvent: CreateCustomEvent, options?: AxiosRequestConfig) {
        return ProjectCustomEventsApiFp(this.configuration).createCustomEvent(projectId, createCustomEvent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectCustomNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export const ProjectCustomNotificationSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription: async (projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNotificationSubscription', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/customNotificationSubscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomNotificationSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription: async (projectId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteNotificationSubscription', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteNotificationSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription: async (projectId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationSubscription', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getNotificationSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationSubscriptions', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/customNotificationSubscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription: async (projectId: string, subscriptionId: string, ifMatch?: string, customNotificationSubscription?: CustomNotificationSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateNotificationSubscription', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateNotificationSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/customNotificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customNotificationSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectCustomNotificationSubscriptionsApi - functional programming interface
 * @export
 */
export const ProjectCustomNotificationSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectCustomNotificationSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationSubscription(projectId, createCustomNotificationSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationSubscription(projectId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscription(projectId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscriptions(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNotificationSubscriptionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscriptions(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string, customNotificationSubscription?: CustomNotificationSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomNotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectCustomNotificationSubscriptionsApi - factory interface
 * @export
 */
export const ProjectCustomNotificationSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectCustomNotificationSubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription, options?: any): AxiosPromise<CustomNotificationSubscription> {
            return localVarFp.createNotificationSubscription(projectId, createCustomNotificationSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a custom notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotificationSubscription(projectId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription(projectId: string, subscriptionId: string, options?: any): AxiosPromise<CustomNotificationSubscription> {
            return localVarFp.getNotificationSubscription(projectId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions(projectId: string, options?: any): AxiosPromise<CustomNotificationSubscriptionList> {
            return localVarFp.getNotificationSubscriptions(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the custom notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string, customNotificationSubscription?: CustomNotificationSubscription, options?: any): AxiosPromise<CustomNotificationSubscription> {
            return localVarFp.updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectCustomNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectCustomNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export class ProjectCustomNotificationSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateCustomNotificationSubscription} [createCustomNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    public createNotificationSubscription(projectId: string, createCustomNotificationSubscription?: CreateCustomNotificationSubscription, options?: AxiosRequestConfig) {
        return ProjectCustomNotificationSubscriptionsApiFp(this.configuration).createNotificationSubscription(projectId, createCustomNotificationSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a custom notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    public deleteNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ProjectCustomNotificationSubscriptionsApiFp(this.configuration).deleteNotificationSubscription(projectId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    public getNotificationSubscription(projectId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ProjectCustomNotificationSubscriptionsApiFp(this.configuration).getNotificationSubscription(projectId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    public getNotificationSubscriptions(projectId: string, options?: AxiosRequestConfig) {
        return ProjectCustomNotificationSubscriptionsApiFp(this.configuration).getNotificationSubscriptions(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the custom notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {CustomNotificationSubscription} [customNotificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectCustomNotificationSubscriptionsApi
     */
    public updateNotificationSubscription(projectId: string, subscriptionId: string, ifMatch?: string, customNotificationSubscription?: CustomNotificationSubscription, options?: AxiosRequestConfig) {
        return ProjectCustomNotificationSubscriptionsApiFp(this.configuration).updateNotificationSubscription(projectId, subscriptionId, ifMatch, customNotificationSubscription, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectDataApi - axios parameter creator
 * @export
 */
export const ProjectDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('archiveData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:archive`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFolderUploadSession: async (projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('completeFolderUploadSession', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('completeFolderUploadSession', 'dataId', dataId)
            // verify required parameter 'folderUploadSessionId' is not null or undefined
            assertParamExists('completeFolderUploadSession', 'folderUploadSessionId', folderUploadSessionId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}/folderUploadSessions/{folderUploadSessionId}:complete`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)))
                .replace(`{${"folderUploadSessionId"}}`, encodeURIComponent(String(folderUploadSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeFolderUploadSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create data in this project.
         * @param {string} projectId 
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataInProject: async (projectId: string, createData?: CreateData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDataInProject', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadUrlForData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDownloadUrlForData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('createDownloadUrlForData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:createDownloadUrl`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderUploadSession: async (projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createFolderUploadSession', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('createFolderUploadSession', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}/folderUploadSessions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemporaryCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInlineViewUrlForData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createInlineViewUrlForData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('createInlineViewUrlForData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:createInlineViewUrl`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemporaryCredentialsForData: async (projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createTemporaryCredentialsForData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('createTemporaryCredentialsForData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:createTemporaryCredentials`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemporaryCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} [fileType] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUrlForData: async (projectId: string, dataId: string, fileType?: string, hash?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createUploadUrlForData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('createUploadUrlForData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:createUploadUrl`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileType !== undefined) {
                localVarQueryParameter['fileType'] = fileType;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('deleteData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:delete`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEligibleForLinking: async (projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataEligibleForLinking', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/data/eligibleForLinking`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fullText !== undefined) {
                localVarQueryParameter['fullText'] = fullText;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (filename) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filenameMatchMode !== undefined) {
                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
            }

            if (filePath) {
                localVarQueryParameter['filePath'] = filePath;
            }

            if (filePathMatchMode !== undefined) {
                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (formatId) {
                localVarQueryParameter['formatId'] = formatId;
            }

            if (formatCode) {
                localVarQueryParameter['formatCode'] = formatCode;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (parentFolderId) {
                localVarQueryParameter['parentFolderId'] = parentFolderId;
            }

            if (parentFolderPath !== undefined) {
                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
            }

            if (creationDateAfter !== undefined) {
                localVarQueryParameter['creationDateAfter'] = (creationDateAfter as any instanceof Date) ?
                    (creationDateAfter as any).toISOString() :
                    creationDateAfter;
            }

            if (creationDateBefore !== undefined) {
                localVarQueryParameter['creationDateBefore'] = (creationDateBefore as any instanceof Date) ?
                    (creationDateBefore as any).toISOString() :
                    creationDateBefore;
            }

            if (statusDateAfter !== undefined) {
                localVarQueryParameter['statusDateAfter'] = (statusDateAfter as any instanceof Date) ?
                    (statusDateAfter as any).toISOString() :
                    statusDateAfter;
            }

            if (statusDateBefore !== undefined) {
                localVarQueryParameter['statusDateBefore'] = (statusDateBefore as any instanceof Date) ?
                    (statusDateBefore as any).toISOString() :
                    statusDateBefore;
            }

            if (userTag) {
                localVarQueryParameter['userTag'] = userTag;
            }

            if (userTagMatchMode !== undefined) {
                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
            }

            if (runInputTag) {
                localVarQueryParameter['runInputTag'] = runInputTag;
            }

            if (runInputTagMatchMode !== undefined) {
                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
            }

            if (runOutputTag) {
                localVarQueryParameter['runOutputTag'] = runOutputTag;
            }

            if (runOutputTagMatchMode !== undefined) {
                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
            }

            if (connectorTag) {
                localVarQueryParameter['connectorTag'] = connectorTag;
            }

            if (connectorTagMatchMode !== undefined) {
                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
            }

            if (technicalTag) {
                localVarQueryParameter['technicalTag'] = technicalTag;
            }

            if (technicalTagMatchMode !== undefined) {
                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
            }

            if (notInRun !== undefined) {
                localVarQueryParameter['notInRun'] = notInRun;
            }

            if (notLinkedToSample !== undefined) {
                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderUploadSession: async (projectId: string, dataId: string, folderUploadSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFolderUploadSession', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('getFolderUploadSession', 'dataId', dataId)
            // verify required parameter 'folderUploadSessionId' is not null or undefined
            assertParamExists('getFolderUploadSession', 'folderUploadSessionId', folderUploadSessionId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}/folderUploadSessions/{folderUploadSessionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)))
                .replace(`{${"folderUploadSessionId"}}`, encodeURIComponent(String(folderUploadSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSampleProjectData: async (projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNonSampleProjectData', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/data/nonSampleData`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('getProjectData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the children of this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataChildren: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDataChildren', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('getProjectDataChildren', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}/children`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of project data.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataList: async (projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectDataList', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fullText !== undefined) {
                localVarQueryParameter['fullText'] = fullText;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (filename) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filenameMatchMode !== undefined) {
                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
            }

            if (filePath) {
                localVarQueryParameter['filePath'] = filePath;
            }

            if (filePathMatchMode !== undefined) {
                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (formatId) {
                localVarQueryParameter['formatId'] = formatId;
            }

            if (formatCode) {
                localVarQueryParameter['formatCode'] = formatCode;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (parentFolderId) {
                localVarQueryParameter['parentFolderId'] = parentFolderId;
            }

            if (parentFolderPath !== undefined) {
                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
            }

            if (creationDateAfter !== undefined) {
                localVarQueryParameter['creationDateAfter'] = (creationDateAfter as any instanceof Date) ?
                    (creationDateAfter as any).toISOString() :
                    creationDateAfter;
            }

            if (creationDateBefore !== undefined) {
                localVarQueryParameter['creationDateBefore'] = (creationDateBefore as any instanceof Date) ?
                    (creationDateBefore as any).toISOString() :
                    creationDateBefore;
            }

            if (statusDateAfter !== undefined) {
                localVarQueryParameter['statusDateAfter'] = (statusDateAfter as any instanceof Date) ?
                    (statusDateAfter as any).toISOString() :
                    statusDateAfter;
            }

            if (statusDateBefore !== undefined) {
                localVarQueryParameter['statusDateBefore'] = (statusDateBefore as any instanceof Date) ?
                    (statusDateBefore as any).toISOString() :
                    statusDateBefore;
            }

            if (userTag) {
                localVarQueryParameter['userTag'] = userTag;
            }

            if (userTagMatchMode !== undefined) {
                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
            }

            if (runInputTag) {
                localVarQueryParameter['runInputTag'] = runInputTag;
            }

            if (runInputTagMatchMode !== undefined) {
                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
            }

            if (runOutputTag) {
                localVarQueryParameter['runOutputTag'] = runOutputTag;
            }

            if (runOutputTagMatchMode !== undefined) {
                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
            }

            if (connectorTag) {
                localVarQueryParameter['connectorTag'] = connectorTag;
            }

            if (connectorTagMatchMode !== undefined) {
                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
            }

            if (technicalTag) {
                localVarQueryParameter['technicalTag'] = technicalTag;
            }

            if (technicalTagMatchMode !== undefined) {
                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
            }

            if (notInRun !== undefined) {
                localVarQueryParameter['notInRun'] = notInRun;
            }

            if (notLinkedToSample !== undefined) {
                localVarQueryParameter['notLinkedToSample'] = notLinkedToSample;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsLinkedToData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectsLinkedToData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('getProjectsLinkedToData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}/linkedProjects`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link data to this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToProject: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('linkDataToProject', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('linkDataToProject', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ScheduleDownload} scheduleDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDownloadForData: async (projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('scheduleDownloadForData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('scheduleDownloadForData', 'dataId', dataId)
            // verify required parameter 'scheduleDownload' is not null or undefined
            assertParamExists('scheduleDownloadForData', 'scheduleDownload', scheduleDownload)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:scheduleDownload`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleDownload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveData: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unarchiveData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('unarchiveData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:unarchive`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink data from this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromProject: async (projectId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unlinkDataFromProject', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('unlinkDataFromProject', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}:unlink`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags  
         * @summary Update this project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectData: async (projectId: string, dataId: string, projectData?: ProjectData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectData', 'projectId', projectId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('updateProjectData', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/data/{dataId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDataApi - functional programming interface
 * @export
 */
export const ProjectDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderUploadSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create data in this project.
         * @param {string} projectId 
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataInProject(projectId: string, createData?: CreateData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataInProject(projectId, createData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDownloadUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Download>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDownloadUrlForData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderUploadSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInlineViewUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInlineViewUrlForData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TempCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} [fileType] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUploadUrlForData(projectId: string, dataId: string, fileType?: string, hash?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadUrlForData(projectId, dataId, fileType, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataEligibleForLinking(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderUploadSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderUploadSession(projectId, dataId, folderUploadSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNonSampleProjectData(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDataPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the children of this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDataChildren(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDataChildren(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the list of project data.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectDataList(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDataPagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectsLinkedToData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsLinkedToData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link data to this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkDataToProject(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkDataToProject(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ScheduleDownload} scheduleDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleDownloadForData(projectId, dataId, scheduleDownload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveData(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveData(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink data from this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkDataFromProject(projectId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkDataFromProject(projectId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags  
         * @summary Update this project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectData(projectId: string, dataId: string, projectData?: ProjectData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectData(projectId, dataId, projectData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectDataApi - factory interface
 * @export
 */
export const ProjectDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDataApiFp(configuration)
    return {
        /**
         * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for archival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveData(projectId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.archiveData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
         * @summary Complete a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession, options?: any): AxiosPromise<FolderUploadSession> {
            return localVarFp.completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create data in this project.
         * @param {string} projectId 
         * @param {CreateData} [createData] The data to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataInProject(projectId: string, createData?: CreateData, options?: any): AxiosPromise<ProjectData> {
            return localVarFp.createDataInProject(projectId, createData, options).then((request) => request(axios, basePath));
        },
        /**
         * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve a download URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDownloadUrlForData(projectId: string, dataId: string, options?: any): AxiosPromise<Download> {
            return localVarFp.createDownloadUrlForData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
         * @summary Create a trackable folder upload session.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: any): AxiosPromise<FolderUploadSession> {
            return localVarFp.createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an URL for this data to use for inline view in a browser.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInlineViewUrlForData(projectId: string, dataId: string, options?: any): AxiosPromise<InlineView> {
            return localVarFp.createInlineViewUrlForData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
         * @summary Retrieve temporary credentials for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: any): AxiosPromise<TempCredentials> {
            return localVarFp.createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
         * @summary Retrieve an upload URL for this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} [fileType] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUrlForData(projectId: string, dataId: string, fileType?: string, hash?: string, options?: any): AxiosPromise<Upload> {
            return localVarFp.createUploadUrlForData(projectId, dataId, fileType, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for deletion.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData(projectId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of data eligible for linking to the current project.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataEligibleForLinking(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<DataPagedList> {
            return localVarFp.getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve folder upload session details, including the current status of your upload session.
         * @summary Retrieve folder upload session details.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {string} folderUploadSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: any): AxiosPromise<FolderUploadSession> {
            return localVarFp.getFolderUploadSession(projectId, dataId, folderUploadSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of project data not linked to a sample.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSampleProjectData(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, options?: any): AxiosPromise<ProjectDataPagedList> {
            return localVarFp.getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectData(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectData> {
            return localVarFp.getProjectData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the children of this data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataChildren(projectId: string, dataId: string, options?: any): AxiosPromise<DataList> {
            return localVarFp.getProjectDataChildren(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of project data.
         * @param {string} projectId 
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDataList(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<ProjectDataPagedList> {
            return localVarFp.getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of projects to which this data is linked.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsLinkedToData(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectList> {
            return localVarFp.getProjectsLinkedToData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link data to this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToProject(projectId: string, dataId: string, options?: any): AxiosPromise<ProjectData> {
            return localVarFp.linkDataToProject(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule a download.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ScheduleDownload} scheduleDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: any): AxiosPromise<DataTransfer> {
            return localVarFp.scheduleDownloadForData(projectId, dataId, scheduleDownload, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Schedule this data for unarchival.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveData(projectId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unarchiveData(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink data from this project.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromProject(projectId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkDataFromProject(projectId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags  
         * @summary Update this project data.
         * @param {string} projectId 
         * @param {string} dataId 
         * @param {ProjectData} [projectData] The updated project data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectData(projectId: string, dataId: string, projectData?: ProjectData, options?: any): AxiosPromise<ProjectData> {
            return localVarFp.updateProjectData(projectId, dataId, projectData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDataApi - object-oriented interface
 * @export
 * @class ProjectDataApi
 * @extends {BaseAPI}
 */
export class ProjectDataApi extends BaseAPI {
    /**
     * Endpoint for scheduling this data for archival. This will also archive all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for archival.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public archiveData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).archiveData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete a trackable folder upload session. By completing the folder upload session, and specifying how many files you have uploaded, ICA can ensure that all uploaded files are accounted for.
     * @summary Complete a trackable folder upload session.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {string} folderUploadSessionId 
     * @param {CompleteFolderUploadSession} [completeFolderUploadSession] The info required to complete the folder upload session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public completeFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, completeFolderUploadSession?: CompleteFolderUploadSession, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).completeFolderUploadSession(projectId, dataId, folderUploadSessionId, completeFolderUploadSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create data in this project.
     * @param {string} projectId 
     * @param {CreateData} [createData] The data to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createDataInProject(projectId: string, createData?: CreateData, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createDataInProject(projectId, createData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can be used to download a file directly from the region where it is located, no connector is needed. Only small files can be downloaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve a download URL for this data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createDownloadUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createDownloadUrlForData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to ensure that all uploaded files within the requested session are accounted for. This call has to be used together with the :complete endpoint once upload is done.
     * @summary Create a trackable folder upload session.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createFolderUploadSession(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createFolderUploadSession(projectId, dataId, createTemporaryCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can be used to view a file directly from the region where it is located, no connector is needed. Only small files can be viewed, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an URL for this data to use for inline view in a browser.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createInlineViewUrlForData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createInlineViewUrlForData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can be used to upload or download a file directly from the region where it is located, no connector is needed.
     * @summary Retrieve temporary credentials for this data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {CreateTemporaryCredentials} [createTemporaryCredentials] Temporary credentials request options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createTemporaryCredentialsForData(projectId: string, dataId: string, createTemporaryCredentials?: CreateTemporaryCredentials, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createTemporaryCredentialsForData(projectId, dataId, createTemporaryCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can be used to upload a file directly from the region where it is located, no connector is needed. Only small files can be uploaded, otherwise a response with status 400 will be returned if the file is too big.
     * @summary Retrieve an upload URL for this data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {string} [fileType] 
     * @param {string} [hash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public createUploadUrlForData(projectId: string, dataId: string, fileType?: string, hash?: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).createUploadUrlForData(projectId, dataId, fileType, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for scheduling this data for deletion. This will also delete all files and directories below that data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for deletion.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public deleteData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).deleteData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of data eligible for linking to the current project.
     * @param {string} projectId 
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned. This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getDataEligibleForLinking(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getDataEligibleForLinking(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve folder upload session details, including the current status of your upload session.
     * @summary Retrieve folder upload session details.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {string} folderUploadSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getFolderUploadSession(projectId: string, dataId: string, folderUploadSessionId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getFolderUploadSession(projectId, dataId, folderUploadSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of project data not linked to a sample.
     * @param {string} projectId 
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getNonSampleProjectData(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getNonSampleProjectData(projectId, pageOffset, pageToken, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a project data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getProjectData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getProjectData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the children of this data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getProjectDataChildren(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getProjectDataChildren(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of project data.
     * @param {string} projectId 
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {boolean} [notLinkedToSample] When set to true only data that is unlinked to a sample will be returned.  This filter implies a filter of type File.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getProjectDataList(projectId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, notLinkedToSample?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getProjectDataList(projectId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, notLinkedToSample, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of projects to which this data is linked.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public getProjectsLinkedToData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).getProjectsLinkedToData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link data to this project.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public linkDataToProject(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).linkDataToProject(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for scheduling a download for the data specified by the ID to a connector. This download will only start when the connector is running. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule a download.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {ScheduleDownload} scheduleDownload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public scheduleDownloadForData(projectId: string, dataId: string, scheduleDownload: ScheduleDownload, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).scheduleDownloadForData(projectId, dataId, scheduleDownload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for scheduling this data for unarchival. This will also unarchive all files and directories below that data. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Schedule this data for unarchival.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public unarchiveData(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).unarchiveData(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink data from this project.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public unlinkDataFromProject(projectId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).unlinkDataFromProject(projectId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated for files:  - data.willBeArchivedAt  - data.willBeDeletedAt  - data.format  - data.tags  Fields which can be updated for folders:  - data.tags  
     * @summary Update this project data.
     * @param {string} projectId 
     * @param {string} dataId 
     * @param {ProjectData} [projectData] The updated project data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataApi
     */
    public updateProjectData(projectId: string, dataId: string, projectData?: ProjectData, options?: AxiosRequestConfig) {
        return ProjectDataApiFp(this.configuration).updateProjectData(projectId, dataId, projectData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectDataTransferApi - axios parameter creator
 * @export
 */
export const ProjectDataTransferApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortDataTransfer: async (projectId: string, dataTransferId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('abortDataTransfer', 'projectId', projectId)
            // verify required parameter 'dataTransferId' is not null or undefined
            assertParamExists('abortDataTransfer', 'dataTransferId', dataTransferId)
            const localVarPath = `/api/projects/{projectId}/dataTransfers/{dataTransferId}:abort`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataTransferId"}}`, encodeURIComponent(String(dataTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfer: async (projectId: string, dataTransferId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataTransfer', 'projectId', projectId)
            // verify required parameter 'dataTransferId' is not null or undefined
            assertParamExists('getDataTransfer', 'dataTransferId', dataTransferId)
            const localVarPath = `/api/projects/{projectId}/dataTransfers/{dataTransferId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"dataTransferId"}}`, encodeURIComponent(String(dataTransferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId 
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfers: async (projectId: string, connector?: string, direction?: string, status?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataTransfers', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/dataTransfers`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (connector !== undefined) {
                localVarQueryParameter['connector'] = connector;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDataTransferApi - functional programming interface
 * @export
 */
export const ProjectDataTransferApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectDataTransferApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abortDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abortDataTransfer(projectId, dataTransferId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTransfer(projectId, dataTransferId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId 
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTransfers(projectId: string, connector?: string, direction?: string, status?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataTransfers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectDataTransferApi - factory interface
 * @export
 */
export const ProjectDataTransferApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectDataTransferApiFp(configuration)
    return {
        /**
         * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Abort a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortDataTransfer(projectId: string, dataTransferId: string, options?: any): AxiosPromise<void> {
            return localVarFp.abortDataTransfer(projectId, dataTransferId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a data transfer.
         * @param {string} projectId 
         * @param {string} dataTransferId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfer(projectId: string, dataTransferId: string, options?: any): AxiosPromise<DataTransfer> {
            return localVarFp.getDataTransfer(projectId, dataTransferId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
         * @summary Retrieve a list of data transfers.
         * @param {string} projectId 
         * @param {string} [connector] The ID of the connector to filter on.
         * @param {string} [direction] The direction to filter on.
         * @param {string} [status] The status to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTransfers(projectId: string, connector?: string, direction?: string, status?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<DataTransfers> {
            return localVarFp.getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectDataTransferApi - object-oriented interface
 * @export
 * @class ProjectDataTransferApi
 * @extends {BaseAPI}
 */
export class ProjectDataTransferApi extends BaseAPI {
    /**
     * Endpoint for aborting a data transfer.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Abort a data transfer.
     * @param {string} projectId 
     * @param {string} dataTransferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    public abortDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig) {
        return ProjectDataTransferApiFp(this.configuration).abortDataTransfer(projectId, dataTransferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a data transfer.
     * @param {string} projectId 
     * @param {string} dataTransferId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    public getDataTransfer(projectId: string, dataTransferId: string, options?: AxiosRequestConfig) {
        return ProjectDataTransferApiFp(this.configuration).getDataTransfer(projectId, dataTransferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of data transfers for the current app (session), excluding web browser transfers.
     * @summary Retrieve a list of data transfers.
     * @param {string} projectId 
     * @param {string} [connector] The ID of the connector to filter on.
     * @param {string} [direction] The direction to filter on.
     * @param {string} [status] The status to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - reference - direction - connector - protocol - dataTransferred - status - statusMessage - duration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDataTransferApi
     */
    public getDataTransfers(projectId: string, connector?: string, direction?: string, status?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectDataTransferApiFp(this.configuration).getDataTransfers(projectId, connector, direction, status, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectNotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export const ProjectNotificationSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription1: async (projectId: string, createNotificationSubscription?: CreateNotificationSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNotificationSubscription1', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/notificationSubscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription1: async (projectId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteNotificationSubscription1', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteNotificationSubscription1', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription1: async (projectId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationSubscription1', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getNotificationSubscription1', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions1: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationSubscriptions1', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/notificationSubscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription1: async (projectId: string, subscriptionId: string, ifMatch?: string, notificationSubscription?: NotificationSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateNotificationSubscription1', 'projectId', projectId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateNotificationSubscription1', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/projects/{projectId}/notificationSubscriptions/{subscriptionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectNotificationSubscriptionsApi - functional programming interface
 * @export
 */
export const ProjectNotificationSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectNotificationSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationSubscription1(projectId, createNotificationSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationSubscription1(projectId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscription1(projectId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscriptions1(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscriptionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscriptions1(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string, notificationSubscription?: NotificationSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectNotificationSubscriptionsApi - factory interface
 * @export
 */
export const ProjectNotificationSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectNotificationSubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a notification subscription
         * @param {string} projectId The ID of the project
         * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription, options?: any): AxiosPromise<NotificationSubscription> {
            return localVarFp.createNotificationSubscription1(projectId, createNotificationSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotificationSubscription1(projectId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription1(projectId: string, subscriptionId: string, options?: any): AxiosPromise<NotificationSubscription> {
            return localVarFp.getNotificationSubscription1(projectId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve notification subscriptions
         * @param {string} projectId The ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions1(projectId: string, options?: any): AxiosPromise<NotificationSubscriptionList> {
            return localVarFp.getNotificationSubscriptions1(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
         * @summary Update a notification subscription
         * @param {string} projectId The ID of the project
         * @param {string} subscriptionId The ID of the notification subscription to update
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {NotificationSubscription} [notificationSubscription] The updated subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string, notificationSubscription?: NotificationSubscription, options?: any): AxiosPromise<NotificationSubscription> {
            return localVarFp.updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectNotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class ProjectNotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export class ProjectNotificationSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a notification subscription
     * @param {string} projectId The ID of the project
     * @param {CreateNotificationSubscription} [createNotificationSubscription] The new subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    public createNotificationSubscription1(projectId: string, createNotificationSubscription?: CreateNotificationSubscription, options?: AxiosRequestConfig) {
        return ProjectNotificationSubscriptionsApiFp(this.configuration).createNotificationSubscription1(projectId, createNotificationSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    public deleteNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ProjectNotificationSubscriptionsApiFp(this.configuration).deleteNotificationSubscription1(projectId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    public getNotificationSubscription1(projectId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ProjectNotificationSubscriptionsApiFp(this.configuration).getNotificationSubscription1(projectId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve notification subscriptions
     * @param {string} projectId The ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    public getNotificationSubscriptions1(projectId: string, options?: AxiosRequestConfig) {
        return ProjectNotificationSubscriptionsApiFp(this.configuration).getNotificationSubscriptions1(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated:  - enabled  - eventCode  - filterExpression  - notificationChannel 
     * @summary Update a notification subscription
     * @param {string} projectId The ID of the project
     * @param {string} subscriptionId The ID of the notification subscription to update
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {NotificationSubscription} [notificationSubscription] The updated subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectNotificationSubscriptionsApi
     */
    public updateNotificationSubscription1(projectId: string, subscriptionId: string, ifMatch?: string, notificationSubscription?: NotificationSubscription, options?: AxiosRequestConfig) {
        return ProjectNotificationSubscriptionsApiFp(this.configuration).updateNotificationSubscription1(projectId, subscriptionId, ifMatch, notificationSubscription, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectPermissionApi - axios parameter creator
 * @export
 */
export const ProjectPermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a project permission.
         * @param {string} projectId 
         * @param {CreateProjectPermission} [createProjectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectPermission: async (projectId: string, createProjectPermission?: CreateProjectPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectPermission', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/permissions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermission: async (projectId: string, permissionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPermission', 'projectId', projectId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getProjectPermission', 'permissionId', permissionId)
            const localVarPath = `/api/projects/{projectId}/permissions/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermissions: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPermissions', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/permissions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectPermission: async (projectId: string, permissionId: string, ifMatch?: string, projectPermission?: ProjectPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectPermission', 'projectId', projectId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('updateProjectPermission', 'permissionId', permissionId)
            const localVarPath = `/api/projects/{projectId}/permissions/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectPermissionApi - functional programming interface
 * @export
 */
export const ProjectPermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectPermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a project permission.
         * @param {string} projectId 
         * @param {CreateProjectPermission} [createProjectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectPermission(projectId, createProjectPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPermission(projectId: string, permissionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPermission(projectId, permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPermissions(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPermissionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPermissions(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string, projectPermission?: ProjectPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectPermissionApi - factory interface
 * @export
 */
export const ProjectPermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectPermissionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a project permission.
         * @param {string} projectId 
         * @param {CreateProjectPermission} [createProjectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission, options?: any): AxiosPromise<ProjectPermission> {
            return localVarFp.createProjectPermission(projectId, createProjectPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermission(projectId: string, permissionId: string, options?: any): AxiosPromise<ProjectPermission> {
            return localVarFp.getProjectPermission(projectId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of project permissions.
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPermissions(projectId: string, options?: any): AxiosPromise<ProjectPermissionList> {
            return localVarFp.getProjectPermissions(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
         * @summary Update a project permission.
         * @param {string} projectId 
         * @param {string} permissionId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectPermission} [projectPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string, projectPermission?: ProjectPermission, options?: any): AxiosPromise<ProjectPermission> {
            return localVarFp.updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectPermissionApi - object-oriented interface
 * @export
 * @class ProjectPermissionApi
 * @extends {BaseAPI}
 */
export class ProjectPermissionApi extends BaseAPI {
    /**
     * 
     * @summary Create a project permission.
     * @param {string} projectId 
     * @param {CreateProjectPermission} [createProjectPermission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    public createProjectPermission(projectId: string, createProjectPermission?: CreateProjectPermission, options?: AxiosRequestConfig) {
        return ProjectPermissionApiFp(this.configuration).createProjectPermission(projectId, createProjectPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a project permission.
     * @param {string} projectId 
     * @param {string} permissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    public getProjectPermission(projectId: string, permissionId: string, options?: AxiosRequestConfig) {
        return ProjectPermissionApiFp(this.configuration).getProjectPermission(projectId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of project permissions.
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    public getProjectPermissions(projectId: string, options?: AxiosRequestConfig) {
        return ProjectPermissionApiFp(this.configuration).getProjectPermissions(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated: - uploadAllowed - downloadAllowed - roleProject - roleFlow - roleBase - roleBench
     * @summary Update a project permission.
     * @param {string} projectId 
     * @param {string} permissionId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectPermission} [projectPermission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPermissionApi
     */
    public updateProjectPermission(projectId: string, permissionId: string, ifMatch?: string, projectPermission?: ProjectPermission, options?: AxiosRequestConfig) {
        return ProjectPermissionApiFp(this.configuration).updateProjectPermission(projectId, permissionId, ifMatch, projectPermission, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectPipelineApi - axios parameter creator
 * @export
 */
export const ProjectPipelineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlPipeline: async (projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createCwlPipeline', 'projectId', projectId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('createCwlPipeline', 'code', code)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createCwlPipeline', 'description', description)
            // verify required parameter 'workflowCwlFile' is not null or undefined
            assertParamExists('createCwlPipeline', 'workflowCwlFile', workflowCwlFile)
            // verify required parameter 'parametersXmlFile' is not null or undefined
            assertParamExists('createCwlPipeline', 'parametersXmlFile', parametersXmlFile)
            // verify required parameter 'analysisStorageId' is not null or undefined
            assertParamExists('createCwlPipeline', 'analysisStorageId', analysisStorageId)
            const localVarPath = `/api/projects/{projectId}/pipelines:createCwlPipeline`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (code !== undefined) { 
                localVarFormParams.append('code', code as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (workflowCwlFile !== undefined) { 
                localVarFormParams.append('workflowCwlFile', workflowCwlFile as any);
            }
                if (toolCwlFiles) {
                toolCwlFiles.forEach((element) => {
                    localVarFormParams.append('toolCwlFiles', element as any);
                })
            }

    
            if (parametersXmlFile !== undefined) { 
                localVarFormParams.append('parametersXmlFile', parametersXmlFile as any);
            }
    
            if (metadataModelFile !== undefined) { 
                localVarFormParams.append('metadataModelFile', metadataModelFile as any);
            }
    
            if (links !== undefined) { 
                localVarFormParams.append('links', new Blob([JSON.stringify(links)], { type: "application/json", }));
            }
    
            if (versionComment !== undefined) { 
                localVarFormParams.append('versionComment', versionComment as any);
            }
                if (categories) {
                localVarFormParams.append('categories', categories.join(COLLECTION_FORMATS.csv));
            }

    
            if (htmlDocumentation !== undefined) { 
                localVarFormParams.append('htmlDocumentation', htmlDocumentation as any);
            }
    
            if (analysisStorageId !== undefined) { 
                localVarFormParams.append('analysisStorageId', analysisStorageId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowPipeline: async (projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createNextflowPipeline', 'projectId', projectId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('createNextflowPipeline', 'code', code)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createNextflowPipeline', 'description', description)
            // verify required parameter 'mainNextflowFile' is not null or undefined
            assertParamExists('createNextflowPipeline', 'mainNextflowFile', mainNextflowFile)
            // verify required parameter 'parametersXmlFile' is not null or undefined
            assertParamExists('createNextflowPipeline', 'parametersXmlFile', parametersXmlFile)
            // verify required parameter 'analysisStorageId' is not null or undefined
            assertParamExists('createNextflowPipeline', 'analysisStorageId', analysisStorageId)
            const localVarPath = `/api/projects/{projectId}/pipelines:createNextflowPipeline`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (code !== undefined) { 
                localVarFormParams.append('code', code as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (mainNextflowFile !== undefined) { 
                localVarFormParams.append('mainNextflowFile', mainNextflowFile as any);
            }
                if (otherNextflowFiles) {
                otherNextflowFiles.forEach((element) => {
                    localVarFormParams.append('otherNextflowFiles', element as any);
                })
            }

    
            if (parametersXmlFile !== undefined) { 
                localVarFormParams.append('parametersXmlFile', parametersXmlFile as any);
            }
    
            if (metadataModelFile !== undefined) { 
                localVarFormParams.append('metadataModelFile', metadataModelFile as any);
            }
    
            if (links !== undefined) { 
                localVarFormParams.append('links', new Blob([JSON.stringify(links)], { type: "application/json", }));
            }
    
            if (versionComment !== undefined) { 
                localVarFormParams.append('versionComment', versionComment as any);
            }
                if (categories) {
                localVarFormParams.append('categories', categories.join(COLLECTION_FORMATS.csv));
            }

    
            if (htmlDocumentation !== undefined) { 
                localVarFormParams.append('htmlDocumentation', htmlDocumentation as any);
            }
    
            if (analysisStorageId !== undefined) { 
                localVarFormParams.append('analysisStorageId', analysisStorageId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipeline: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPipeline', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getProjectPipeline', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineInputParameters: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPipelineInputParameters', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getProjectPipelineInputParameters', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}/inputParameters`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineReferenceSets: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPipelineReferenceSets', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getProjectPipelineReferenceSets', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}/referenceSets`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelines: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectPipelines', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/pipelines`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToProject: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('linkPipelineToProject', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('linkPipelineToProject', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePipeline: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('releasePipeline', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('releasePipeline', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}:release`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromProject: async (projectId: string, pipelineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unlinkPipelineFromProject', 'projectId', projectId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('unlinkPipelineFromProject', 'pipelineId', pipelineId)
            const localVarPath = `/api/projects/{projectId}/pipelines/{pipelineId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectPipelineApi - functional programming interface
 * @export
 */
export const ProjectPipelineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectPipelineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPipeline(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InputParameterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPipelineInputParameters(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceSetList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPipelineReferenceSets(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectPipelines(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPipelineList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectPipelines(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPipelineToProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkPipelineToProject(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releasePipeline(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkPipelineFromProject(projectId, pipelineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectPipelineApi - factory interface
 * @export
 */
export const ProjectPipelineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectPipelineApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a CWL pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the CWL pipeline
         * @param {string} description The description of the CWL pipeline
         * @param {any} workflowCwlFile The CWL workflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [toolCwlFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: any): AxiosPromise<ProjectPipeline> {
            return localVarFp.createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Nextflow pipeline within a project.
         * @param {string} projectId The ID of the project
         * @param {string} code The code of the pipeline
         * @param {string} description The description of the pipeline
         * @param {any} mainNextflowFile The main Nextflow file.
         * @param {any} parametersXmlFile 
         * @param {string} analysisStorageId The id of the storage to use for the pipeline.
         * @param {Array<any>} [otherNextflowFiles] 
         * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
         * @param {Links} [links] 
         * @param {string} [versionComment] 
         * @param {Array<string>} [categories] 
         * @param {string} [htmlDocumentation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: any): AxiosPromise<ProjectPipeline> {
            return localVarFp.createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipeline(projectId: string, pipelineId: string, options?: any): AxiosPromise<ProjectPipeline> {
            return localVarFp.getProjectPipeline(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve input parameters for a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: any): AxiosPromise<InputParameterList> {
            return localVarFp.getProjectPipelineInputParameters(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
         * @summary Retrieve the reference sets of a project pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: any): AxiosPromise<ReferenceSetList> {
            return localVarFp.getProjectPipelineReferenceSets(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
         * @summary Retrieve a list of project pipelines.
         * @param {string} projectId The ID of the project to retrieve pipelines for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPipelines(projectId: string, options?: any): AxiosPromise<ProjectPipelineList> {
            return localVarFp.getProjectPipelines(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a pipeline to a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPipelineToProject(projectId: string, pipelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkPipelineToProject(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Release a pipeline.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePipeline(projectId: string, pipelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.releasePipeline(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a pipeline from a project.
         * @param {string} projectId The ID of the project
         * @param {string} pipelineId The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkPipelineFromProject(projectId, pipelineId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectPipelineApi - object-oriented interface
 * @export
 * @class ProjectPipelineApi
 * @extends {BaseAPI}
 */
export class ProjectPipelineApi extends BaseAPI {
    /**
     * 
     * @summary Create a CWL pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the CWL pipeline
     * @param {string} description The description of the CWL pipeline
     * @param {any} workflowCwlFile The CWL workflow file.
     * @param {any} parametersXmlFile 
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [toolCwlFiles] 
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links] 
     * @param {string} [versionComment] 
     * @param {Array<string>} [categories] 
     * @param {string} [htmlDocumentation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public createCwlPipeline(projectId: string, code: string, description: string, workflowCwlFile: any, parametersXmlFile: any, analysisStorageId: string, toolCwlFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).createCwlPipeline(projectId, code, description, workflowCwlFile, parametersXmlFile, analysisStorageId, toolCwlFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Nextflow pipeline within a project.
     * @param {string} projectId The ID of the project
     * @param {string} code The code of the pipeline
     * @param {string} description The description of the pipeline
     * @param {any} mainNextflowFile The main Nextflow file.
     * @param {any} parametersXmlFile 
     * @param {string} analysisStorageId The id of the storage to use for the pipeline.
     * @param {Array<any>} [otherNextflowFiles] 
     * @param {any} [metadataModelFile] The metadata model json file(contents can be retrieved from the controlplane).
     * @param {Links} [links] 
     * @param {string} [versionComment] 
     * @param {Array<string>} [categories] 
     * @param {string} [htmlDocumentation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public createNextflowPipeline(projectId: string, code: string, description: string, mainNextflowFile: any, parametersXmlFile: any, analysisStorageId: string, otherNextflowFiles?: Array<any>, metadataModelFile?: any, links?: Links, versionComment?: string, categories?: Array<string>, htmlDocumentation?: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).createNextflowPipeline(projectId, code, description, mainNextflowFile, parametersXmlFile, analysisStorageId, otherNextflowFiles, metadataModelFile, links, versionComment, categories, htmlDocumentation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public getProjectPipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).getProjectPipeline(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve input parameters for a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve input parameters for a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the project pipeline to retrieve input parameters for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public getProjectPipelineInputParameters(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).getProjectPipelineInputParameters(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.
     * @summary Retrieve the reference sets of a project pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline to retrieve reference sets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public getProjectPipelineReferenceSets(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).getProjectPipelineReferenceSets(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of project pipelines. This includes pipelines from linked bundles.
     * @summary Retrieve a list of project pipelines.
     * @param {string} projectId The ID of the project to retrieve pipelines for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public getProjectPipelines(projectId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).getProjectPipelines(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a pipeline to a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public linkPipelineToProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).linkPipelineToProject(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Release a pipeline.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public releasePipeline(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).releasePipeline(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a pipeline from a project.
     * @param {string} projectId The ID of the project
     * @param {string} pipelineId The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectPipelineApi
     */
    public unlinkPipelineFromProject(projectId: string, pipelineId: string, options?: AxiosRequestConfig) {
        return ProjectPipelineApiFp(this.configuration).unlinkPipelineFromProject(projectId, pipelineId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectSampleApi - axios parameter creator
 * @export
 */
export const ProjectSampleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a metadata model to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addMetadataModelToSample: async (projectId: string, sampleId: string, metadataModelId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('addMetadataModelToSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('addMetadataModelToSample', 'sampleId', sampleId)
            // verify required parameter 'metadataModelId' is not null or undefined
            assertParamExists('addMetadataModelToSample', 'metadataModelId', metadataModelId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/metadata/{metadataModelId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)))
                .replace(`{${"metadataModelId"}}`, encodeURIComponent(String(metadataModelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeProjectSample: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('completeProjectSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('completeProjectSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:complete`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new sample in this project
         * @param {string} projectId 
         * @param {CreateSample} [createSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleInProject: async (projectId: string, createSample?: CreateSample, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createSampleInProject', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/samples`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSample, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deepDeleteSample: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deepDeleteSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('deepDeleteSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:deleteDeep`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAndUnlinkSample: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAndUnlinkSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('deleteAndUnlinkSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:deleteUnlink`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSampleWithInput: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteSampleWithInput', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('deleteSampleWithInput', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:deleteWithInput`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a project sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSample: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getProjectSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSamples: async (projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, findProjectSamples?: FindProjectSamples, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectSamples', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/samples:search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(findProjectSamples, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForSample: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProjectsForSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getProjectsForSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/projects`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of sample data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleDataList: async (projectId: string, sampleId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSampleDataList', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getSampleDataList', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/data`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fullText !== undefined) {
                localVarQueryParameter['fullText'] = fullText;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (filename) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filenameMatchMode !== undefined) {
                localVarQueryParameter['filenameMatchMode'] = filenameMatchMode;
            }

            if (filePath) {
                localVarQueryParameter['filePath'] = filePath;
            }

            if (filePathMatchMode !== undefined) {
                localVarQueryParameter['filePathMatchMode'] = filePathMatchMode;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (formatId) {
                localVarQueryParameter['formatId'] = formatId;
            }

            if (formatCode) {
                localVarQueryParameter['formatCode'] = formatCode;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (parentFolderId) {
                localVarQueryParameter['parentFolderId'] = parentFolderId;
            }

            if (parentFolderPath !== undefined) {
                localVarQueryParameter['parentFolderPath'] = parentFolderPath;
            }

            if (creationDateAfter !== undefined) {
                localVarQueryParameter['creationDateAfter'] = (creationDateAfter as any instanceof Date) ?
                    (creationDateAfter as any).toISOString() :
                    creationDateAfter;
            }

            if (creationDateBefore !== undefined) {
                localVarQueryParameter['creationDateBefore'] = (creationDateBefore as any instanceof Date) ?
                    (creationDateBefore as any).toISOString() :
                    creationDateBefore;
            }

            if (statusDateAfter !== undefined) {
                localVarQueryParameter['statusDateAfter'] = (statusDateAfter as any instanceof Date) ?
                    (statusDateAfter as any).toISOString() :
                    statusDateAfter;
            }

            if (statusDateBefore !== undefined) {
                localVarQueryParameter['statusDateBefore'] = (statusDateBefore as any instanceof Date) ?
                    (statusDateBefore as any).toISOString() :
                    statusDateBefore;
            }

            if (userTag) {
                localVarQueryParameter['userTag'] = userTag;
            }

            if (userTagMatchMode !== undefined) {
                localVarQueryParameter['userTagMatchMode'] = userTagMatchMode;
            }

            if (runInputTag) {
                localVarQueryParameter['runInputTag'] = runInputTag;
            }

            if (runInputTagMatchMode !== undefined) {
                localVarQueryParameter['runInputTagMatchMode'] = runInputTagMatchMode;
            }

            if (runOutputTag) {
                localVarQueryParameter['runOutputTag'] = runOutputTag;
            }

            if (runOutputTagMatchMode !== undefined) {
                localVarQueryParameter['runOutputTagMatchMode'] = runOutputTagMatchMode;
            }

            if (connectorTag) {
                localVarQueryParameter['connectorTag'] = connectorTag;
            }

            if (connectorTagMatchMode !== undefined) {
                localVarQueryParameter['connectorTagMatchMode'] = connectorTagMatchMode;
            }

            if (technicalTag) {
                localVarQueryParameter['technicalTag'] = technicalTag;
            }

            if (technicalTagMatchMode !== undefined) {
                localVarQueryParameter['technicalTagMatchMode'] = technicalTagMatchMode;
            }

            if (notInRun !== undefined) {
                localVarQueryParameter['notInRun'] = notInRun;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve sample history.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleHistory: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSampleHistory', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getSampleHistory', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/history`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataField: async (projectId: string, sampleId: string, fieldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSampleMetadataField', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getSampleMetadataField', 'sampleId', sampleId)
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('getSampleMetadataField', 'fieldId', fieldId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/metadata/field/{fieldId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)))
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataFieldCount: async (projectId: string, sampleId: string, fieldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSampleMetadataFieldCount', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('getSampleMetadataFieldCount', 'sampleId', sampleId)
            // verify required parameter 'fieldId' is not null or undefined
            assertParamExists('getSampleMetadataFieldCount', 'fieldId', fieldId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/metadata/{fieldId}/fieldCount`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)))
                .replace(`{${"fieldId"}}`, encodeURIComponent(String(fieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link data to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToSample: async (projectId: string, sampleId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('linkDataToSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('linkDataToSample', 'sampleId', sampleId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('linkDataToSample', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/data/{dataId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link a sample to a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToProject: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('linkSampleToProject', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('linkSampleToProject', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markSampleDeleted: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('markSampleDeleted', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('markSampleDeleted', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:deleteMark`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink data from a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromSample: async (projectId: string, sampleId: string, dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unlinkDataFromSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('unlinkDataFromSample', 'sampleId', sampleId)
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('unlinkDataFromSample', 'dataId', dataId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/data/{dataId}:unlink`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)))
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a sample from a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromProject: async (projectId: string, sampleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unlinkSampleFromProject', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('unlinkSampleFromProject', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}:unlink`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSample: async (projectId: string, sampleId: string, ifMatch?: string, projectSample?: ProjectSample, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectSample', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('updateProjectSample', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectSample, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {UpdateMetadata} [updateMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSampleMetadataFields: async (projectId: string, sampleId: string, updateMetadata?: UpdateMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateSampleMetadataFields', 'projectId', projectId)
            // verify required parameter 'sampleId' is not null or undefined
            assertParamExists('updateSampleMetadataFields', 'sampleId', sampleId)
            const localVarPath = `/api/projects/{projectId}/samples/{sampleId}/metadata:updateFields`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"sampleId"}}`, encodeURIComponent(String(sampleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSampleApi - functional programming interface
 * @export
 */
export const ProjectSampleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectSampleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a metadata model to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetadataModelToSample(projectId, sampleId, metadataModelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeProjectSample(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new sample in this project
         * @param {string} projectId 
         * @param {CreateSample} [createSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSampleInProject(projectId: string, createSample?: CreateSample, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSampleInProject(projectId, createSample, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deepDeleteSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deepDeleteSample(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAndUnlinkSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAndUnlinkSample(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSampleWithInput(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSampleWithInput(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a project sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSample(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectSamples(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, findProjectSamples?: FindProjectSamples, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSamplePagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectsForSample(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsForSample(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the list of sample data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleDataList(projectId: string, sampleId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve sample history.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleHistory(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SampleHistoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleHistory(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Field>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleMetadataField(projectId, sampleId, fieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Field>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleMetadataFieldCount(projectId, sampleId, fieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link data to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkDataToSample(projectId, sampleId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link a sample to a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkSampleToProject(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkSampleToProject(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markSampleDeleted(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markSampleDeleted(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink data from a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkDataFromSample(projectId, sampleId, dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a sample from a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkSampleFromProject(projectId: string, sampleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkSampleFromProject(projectId, sampleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectSample(projectId: string, sampleId: string, ifMatch?: string, projectSample?: ProjectSample, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectSample(projectId, sampleId, ifMatch, projectSample, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {UpdateMetadata} [updateMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSampleMetadataFields(projectId, sampleId, updateMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectSampleApi - factory interface
 * @export
 */
export const ProjectSampleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectSampleApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a metadata model to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} metadataModelId The ID of the metadata model
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: any): AxiosPromise<void> {
            return localVarFp.addMetadataModelToSample(projectId, sampleId, metadataModelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
         * @summary Completes the sample after data has been linked to it.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeProjectSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeProjectSample(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new sample in this project
         * @param {string} projectId 
         * @param {CreateSample} [createSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSampleInProject(projectId: string, createSample?: CreateSample, options?: any): AxiosPromise<ProjectSample> {
            return localVarFp.createSampleInProject(projectId, createSample, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample together with all of its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deepDeleteSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deepDeleteSample(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample and unlink its data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAndUnlinkSample(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAndUnlinkSample(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Delete a sample as well as its input data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSampleWithInput(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSampleWithInput(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a project sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSample(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectSample> {
            return localVarFp.getProjectSample(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Retrieve project samples.
         * @param {string} projectId 
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {FindProjectSamples} [findProjectSamples] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSamples(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, findProjectSamples?: FindProjectSamples, options?: any): AxiosPromise<ProjectSamplePagedList> {
            return localVarFp.getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of projects for this sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForSample(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectList> {
            return localVarFp.getProjectsForSample(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of sample data.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample to retrieve data for
         * @param {string} [fullText] To search through multiple fields of data.
         * @param {Array<string>} [id] The ids to filter on. This will always match exact.
         * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
         * @param {Array<string>} [filePath] The paths of the files to filter on.
         * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
         * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
         * @param {Array<string>} [formatId] The IDs of the formats to filter on.
         * @param {Array<string>} [formatCode] The codes of the formats to filter on.
         * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
         * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
         * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
         * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
         * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
         * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
         * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
         * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
         * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
         * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
         * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleDataList(projectId: string, sampleId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<DataList> {
            return localVarFp.getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve sample history.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleHistory(projectId: string, sampleId: string, options?: any): AxiosPromise<SampleHistoryList> {
            return localVarFp.getSampleHistory(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieve a metadata field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: any): AxiosPromise<Field> {
            return localVarFp.getSampleMetadataField(projectId, sampleId, fieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
         * @summary Retrieves the number of occurrences of a given field.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} fieldId The ID of the field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: any): AxiosPromise<Field> {
            return localVarFp.getSampleMetadataFieldCount(projectId, sampleId, fieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link data to a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.linkDataToSample(projectId, sampleId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link a sample to a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSampleToProject(projectId: string, sampleId: string, options?: any): AxiosPromise<ProjectSample> {
            return localVarFp.linkSampleToProject(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Mark a sample deleted.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markSampleDeleted(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markSampleDeleted(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink data from a sample.
         * @param {string} projectId 
         * @param {string} sampleId The ID of the sample
         * @param {string} dataId The ID of the data to unlink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkDataFromSample(projectId, sampleId, dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a sample from a project.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSampleFromProject(projectId: string, sampleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkSampleFromProject(projectId, sampleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
         * @summary Update a project sample.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {ProjectSample} [projectSample] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSample(projectId: string, sampleId: string, ifMatch?: string, projectSample?: ProjectSample, options?: any): AxiosPromise<ProjectSample> {
            return localVarFp.updateProjectSample(projectId, sampleId, ifMatch, projectSample, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Update metadata fields.
         * @param {string} projectId 
         * @param {string} sampleId 
         * @param {UpdateMetadata} [updateMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata, options?: any): AxiosPromise<Sample> {
            return localVarFp.updateSampleMetadataFields(projectId, sampleId, updateMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectSampleApi - object-oriented interface
 * @export
 * @class ProjectSampleApi
 * @extends {BaseAPI}
 */
export class ProjectSampleApi extends BaseAPI {
    /**
     * 
     * @summary Add a metadata model to a sample.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {string} metadataModelId The ID of the metadata model
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public addMetadataModelToSample(projectId: string, sampleId: string, metadataModelId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).addMetadataModelToSample(projectId, sampleId, metadataModelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes the sample after data has been linked to it. The sample status will be set to \'Available\' and a sample completed event will be triggered as well.
     * @summary Completes the sample after data has been linked to it.
     * @param {string} projectId 
     * @param {string} sampleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public completeProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).completeProjectSample(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new sample in this project
     * @param {string} projectId 
     * @param {CreateSample} [createSample] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public createSampleInProject(projectId: string, createSample?: CreateSample, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).createSampleInProject(projectId, createSample, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint deleting a sample together with all of its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample together with all of its data.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public deepDeleteSample(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).deepDeleteSample(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for deleting a sample while unlinking its data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample and unlink its data.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public deleteAndUnlinkSample(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).deleteAndUnlinkSample(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for deleting a sample as well as its input data.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Delete a sample as well as its input data.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public deleteSampleWithInput(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).deleteSampleWithInput(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a project sample.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getProjectSample(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getProjectSample(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for retrieving project samples. This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Retrieve project samples.
     * @param {string} projectId 
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot; The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {FindProjectSamples} [findProjectSamples] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getProjectSamples(projectId: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, findProjectSamples?: FindProjectSamples, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getProjectSamples(projectId, pageOffset, pageToken, pageSize, sort, findProjectSamples, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of projects for this sample.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getProjectsForSample(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getProjectsForSample(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of sample data.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample to retrieve data for
     * @param {string} [fullText] To search through multiple fields of data.
     * @param {Array<string>} [id] The ids to filter on. This will always match exact.
     * @param {Array<string>} [filename] The filenames to filter on. The filenameMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [filenameMatchMode] How the filenames are filtered. 
     * @param {Array<string>} [filePath] The paths of the files to filter on.
     * @param {'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE'} [filePathMatchMode] How the file paths are filtered:   - STARTS_WITH_CASE_INSENSITIVE: Filters the file path to start with the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. This allows e.g. listing all data in a folder and all it\&#39;s sub-folders (recursively).  - FULL_CASE_INSENSITIVE: Filters the file path to fully match the value of the \&#39;filePath\&#39; parameter, regardless of upper/lower casing. Note that this can result in multiple results if e.g. two files exist with the same filename but different casing (abc.txt and ABC.txt).
     * @param {Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>} [status] The statuses to filter on.
     * @param {Array<string>} [formatId] The IDs of the formats to filter on.
     * @param {Array<string>} [formatCode] The codes of the formats to filter on.
     * @param {'FILE' | 'FOLDER'} [type] The type to filter on.
     * @param {Array<string>} [parentFolderId] The IDs of parents folders to filter on. Lists all files and folders within the folder for the given ID, non-recursively.
     * @param {string} [parentFolderPath] The full path of the parent folder. Should start and end with a \&#39;/\&#39;. Lists all files and folders within the folder for the given path, non-recursively. This can be used to browse through the hierarchical tree of folders, e.g. traversing one level up can be done by removing the last part of the path.
     * @param {string} [creationDateAfter] The date after which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [creationDateBefore] The date before which the data is created. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateAfter] The date after which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {string} [statusDateBefore] The date before which the status has been updated. Format: yyyy-MM-dd\&#39;T\&#39;HH:mm:ss\&#39;Z\&#39; eg: 2021-01-30T08:30:00Z
     * @param {Array<string>} [userTag] The usertags to filter on. The userTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [userTagMatchMode] How the usertags are filtered. 
     * @param {Array<string>} [runInputTag] The runInputTags to filter on. The runInputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runInputTagMatchMode] How the runInputTags are filtered. 
     * @param {Array<string>} [runOutputTag] The runOutputTags to filter on. The runOutputTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [runOutputTagMatchMode] How the runOutputTags are filtered. 
     * @param {Array<string>} [connectorTag] The connectorTags to filter on. The connectorTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [connectorTagMatchMode] How the connectorTags are filtered. 
     * @param {Array<string>} [technicalTag] The technicalTags to filter on. The techTagMatchMode-parameter determines how the filtering is done.
     * @param {'EXACT' | 'EXCLUDE' | 'FUZZY'} [technicalTagMatchMode] How the technicalTags are filtered. 
     * @param {boolean} [notInRun] When set to true, the data will be filtered on data which is not used in a run.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - path - fileSizeInBytes - status - format - dataType - willBeArchivedAt - willBeDeletedAt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getSampleDataList(projectId: string, sampleId: string, fullText?: string, id?: Array<string>, filename?: Array<string>, filenameMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', filePath?: Array<string>, filePathMatchMode?: 'STARTS_WITH_CASE_INSENSITIVE' | 'FULL_CASE_INSENSITIVE', status?: Array<'PARTIAL' | 'AVAILABLE' | 'ARCHIVING' | 'ARCHIVED' | 'UNARCHIVING' | 'DELETING'>, formatId?: Array<string>, formatCode?: Array<string>, type?: 'FILE' | 'FOLDER', parentFolderId?: Array<string>, parentFolderPath?: string, creationDateAfter?: string, creationDateBefore?: string, statusDateAfter?: string, statusDateBefore?: string, userTag?: Array<string>, userTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runInputTag?: Array<string>, runInputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', runOutputTag?: Array<string>, runOutputTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', connectorTag?: Array<string>, connectorTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', technicalTag?: Array<string>, technicalTagMatchMode?: 'EXACT' | 'EXCLUDE' | 'FUZZY', notInRun?: boolean, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getSampleDataList(projectId, sampleId, fullText, id, filename, filenameMatchMode, filePath, filePathMatchMode, status, formatId, formatCode, type, parentFolderId, parentFolderPath, creationDateAfter, creationDateBefore, statusDateAfter, statusDateBefore, userTag, userTagMatchMode, runInputTag, runInputTagMatchMode, runOutputTag, runOutputTagMatchMode, connectorTag, connectorTagMatchMode, technicalTag, technicalTagMatchMode, notInRun, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve sample history.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getSampleHistory(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getSampleHistory(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieve a metadata field.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getSampleMetadataField(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getSampleMetadataField(projectId, sampleId, fieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of values for the field with identifier fieldId belonging to the sample with identifier sampleId. If the field is a group field that can occur more than once or belongs to a group field that can occur more than once the return value will have one entry in the list for each occurrence. If not the return value will be a single value list
     * @summary Retrieves the number of occurrences of a given field.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {string} fieldId The ID of the field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public getSampleMetadataFieldCount(projectId: string, sampleId: string, fieldId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).getSampleMetadataFieldCount(projectId, sampleId, fieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link data to a sample.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public linkDataToSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).linkDataToSample(projectId, sampleId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link a sample to a project.
     * @param {string} projectId 
     * @param {string} sampleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public linkSampleToProject(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).linkSampleToProject(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for marking a sample as deleted.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Mark a sample deleted.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public markSampleDeleted(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).markSampleDeleted(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink data from a sample.
     * @param {string} projectId 
     * @param {string} sampleId The ID of the sample
     * @param {string} dataId The ID of the data to unlink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public unlinkDataFromSample(projectId: string, sampleId: string, dataId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).unlinkDataFromSample(projectId, sampleId, dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a sample from a project.
     * @param {string} projectId 
     * @param {string} sampleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public unlinkSampleFromProject(projectId: string, sampleId: string, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).unlinkSampleFromProject(projectId, sampleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated: - sample.name - sample.description - sample.status - sample.tags
     * @summary Update a project sample.
     * @param {string} projectId 
     * @param {string} sampleId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {ProjectSample} [projectSample] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public updateProjectSample(projectId: string, sampleId: string, ifMatch?: string, projectSample?: ProjectSample, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).updateProjectSample(projectId, sampleId, ifMatch, projectSample, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for updating metadata fields.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Update metadata fields.
     * @param {string} projectId 
     * @param {string} sampleId 
     * @param {UpdateMetadata} [updateMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSampleApi
     */
    public updateSampleMetadataFields(projectId: string, sampleId: string, updateMetadata?: UpdateMetadata, options?: AxiosRequestConfig) {
        return ProjectSampleApiFp(this.configuration).updateSampleMetadataFields(projectId, sampleId, updateMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegionApi - axios parameter creator
 * @export
 */
export const RegionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion: async (regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('getRegion', 'regionId', regionId)
            const localVarPath = `/api/regions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionApi - functional programming interface
 * @export
 */
export const RegionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegion(regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegion(regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegionApi - factory interface
 * @export
 */
export const RegionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegion(regionId: string, options?: any): AxiosPromise<Region> {
            return localVarFp.getRegion(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegions(options?: any): AxiosPromise<RegionList> {
            return localVarFp.getRegions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionApi - object-oriented interface
 * @export
 * @class RegionApi
 * @extends {BaseAPI}
 */
export class RegionApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a region. Only the regions the user has access to through his/her entitlements can be retrieved.
     * @param {string} regionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegion(regionId: string, options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegion(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of regions. Only the regions the user has access to through his/her entitlements are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionApi
     */
    public getRegions(options?: AxiosRequestConfig) {
        return RegionApiFp(this.configuration).getRegions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SampleApi - axios parameter creator
 * @export
 */
export const SampleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamples: async (region: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('getSamples', 'region', region)
            const localVarPath = `/api/samples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userTags !== undefined) {
                localVarQueryParameter['userTags'] = userTags;
            }

            if (technicalTags !== undefined) {
                localVarQueryParameter['technicalTags'] = technicalTags;
            }

            if (pageOffset !== undefined) {
                localVarQueryParameter['pageOffset'] = pageOffset;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SampleApi - functional programming interface
 * @export
 */
export const SampleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SampleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamples(region: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SamplePagedList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SampleApi - factory interface
 * @export
 */
export const SampleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SampleApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of samples.
         * @param {string} region The ID of the region to filter on. This parameter is required.
         * @param {string} [search] To search through multiple fields of data.
         * @param {string} [userTags] The user tags to filter on.
         * @param {string} [technicalTags] The technical tags to filter on.
         * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
         * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
         * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
         * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamples(region: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: any): AxiosPromise<SamplePagedList> {
            return localVarFp.getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SampleApi - object-oriented interface
 * @export
 * @class SampleApi
 * @extends {BaseAPI}
 */
export class SampleApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of samples.
     * @param {string} region The ID of the region to filter on. This parameter is required.
     * @param {string} [search] To search through multiple fields of data.
     * @param {string} [userTags] The user tags to filter on.
     * @param {string} [technicalTags] The technical tags to filter on.
     * @param {string} [pageOffset] The amount of rows to skip in the result. Ideally this is a multiple of the size parameter.
     * @param {string} [pageToken] The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination.
     * @param {string} [pageSize] The amount of rows to return. Use in combination with the offset or cursor parameter to get subsequent results.
     * @param {string} [sort] Which field to order the results by. The default order is ascending, suffix with \&#39; desc\&#39; to sort descending (suffix \&#39; asc\&#39; also works for ascending). Multiple values should be separated with commas. An example: \&quot;?sort&#x3D;dateCreated, lastName desc\&quot;  The attributes for which sorting is supported: - timeCreated - timeModified - name - description - metadataValid - status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SampleApi
     */
    public getSamples(region: string, search?: string, userTags?: string, technicalTags?: string, pageOffset?: string, pageToken?: string, pageSize?: string, sort?: string, options?: AxiosRequestConfig) {
        return SampleApiFp(this.configuration).getSamples(region, search, userTags, technicalTags, pageOffset, pageToken, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageBundleApi - axios parameter creator
 * @export
 */
export const StorageBundleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageBundles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storageBundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageBundleApi - functional programming interface
 * @export
 */
export const StorageBundleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageBundleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageBundles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageBundleList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageBundles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageBundleApi - factory interface
 * @export
 */
export const StorageBundleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageBundleApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of storage bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageBundles(options?: any): AxiosPromise<StorageBundleList> {
            return localVarFp.getStorageBundles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageBundleApi - object-oriented interface
 * @export
 * @class StorageBundleApi
 * @extends {BaseAPI}
 */
export class StorageBundleApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of storage bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageBundleApi
     */
    public getStorageBundles(options?: AxiosRequestConfig) {
        return StorageBundleApiFp(this.configuration).getStorageBundles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageConfigurationApi - axios parameter creator
 * @export
 */
export const StorageConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageConfiguration: async (createStorageConfiguration?: CreateStorageConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storageConfigurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfiguration: async (storageConfigurationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageConfigurationId' is not null or undefined
            assertParamExists('getStorageConfiguration', 'storageConfigurationId', storageConfigurationId)
            const localVarPath = `/api/storageConfigurations/{storageConfigurationId}`
                .replace(`{${"storageConfigurationId"}}`, encodeURIComponent(String(storageConfigurationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurationDetails: async (storageConfigurationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageConfigurationId' is not null or undefined
            assertParamExists('getStorageConfigurationDetails', 'storageConfigurationId', storageConfigurationId)
            const localVarPath = `/api/storageConfigurations/{storageConfigurationId}/details`
                .replace(`{${"storageConfigurationId"}}`, encodeURIComponent(String(storageConfigurationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storageConfigurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageConfiguration: async (storageConfigurationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageConfigurationId' is not null or undefined
            assertParamExists('shareStorageConfiguration', 'storageConfigurationId', storageConfigurationId)
            const localVarPath = `/api/storageConfigurations/{storageConfigurationId}:share`
                .replace(`{${"storageConfigurationId"}}`, encodeURIComponent(String(storageConfigurationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageConfigurationApi - functional programming interface
 * @export
 */
export const StorageConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorageConfiguration(createStorageConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageConfiguration(storageConfigurationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageConfigurationDetails(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageConfigurationDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageConfigurationDetails(storageConfigurationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageConfigurations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageConfigurationWithDetailsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareStorageConfiguration(storageConfigurationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageConfigurationApi - factory interface
 * @export
 */
export const StorageConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageConfigurationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new storage configuration
         * @param {CreateStorageConfiguration} [createStorageConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration, options?: any): AxiosPromise<StorageConfiguration> {
            return localVarFp.createStorageConfiguration(createStorageConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a storage configuration.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfiguration(storageConfigurationId: string, options?: any): AxiosPromise<StorageConfiguration> {
            return localVarFp.getStorageConfiguration(storageConfigurationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a storage configuration detail.
         * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurationDetails(storageConfigurationId: string, options?: any): AxiosPromise<StorageConfigurationDetails> {
            return localVarFp.getStorageConfigurationDetails(storageConfigurationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of storage configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageConfigurations(options?: any): AxiosPromise<StorageConfigurationWithDetailsList> {
            return localVarFp.getStorageConfigurations(options).then((request) => request(axios, basePath));
        },
        /**
         * Here you share your own storage configuration with all the other users in your tenant.
         * @summary Share your own storage configuration with tenant.
         * @param {string} storageConfigurationId The ID of the storage configuration to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageConfiguration(storageConfigurationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.shareStorageConfiguration(storageConfigurationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageConfigurationApi - object-oriented interface
 * @export
 * @class StorageConfigurationApi
 * @extends {BaseAPI}
 */
export class StorageConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary Create a new storage configuration
     * @param {CreateStorageConfiguration} [createStorageConfiguration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    public createStorageConfiguration(createStorageConfiguration?: CreateStorageConfiguration, options?: AxiosRequestConfig) {
        return StorageConfigurationApiFp(this.configuration).createStorageConfiguration(createStorageConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a storage configuration.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    public getStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig) {
        return StorageConfigurationApiFp(this.configuration).getStorageConfiguration(storageConfigurationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a storage configuration detail.
     * @param {string} storageConfigurationId The ID of the storage configuration to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    public getStorageConfigurationDetails(storageConfigurationId: string, options?: AxiosRequestConfig) {
        return StorageConfigurationApiFp(this.configuration).getStorageConfigurationDetails(storageConfigurationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of storage configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    public getStorageConfigurations(options?: AxiosRequestConfig) {
        return StorageConfigurationApiFp(this.configuration).getStorageConfigurations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Here you share your own storage configuration with all the other users in your tenant.
     * @summary Share your own storage configuration with tenant.
     * @param {string} storageConfigurationId The ID of the storage configuration to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageConfigurationApi
     */
    public shareStorageConfiguration(storageConfigurationId: string, options?: AxiosRequestConfig) {
        return StorageConfigurationApiFp(this.configuration).shareStorageConfiguration(storageConfigurationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageCredentialsApi - axios parameter creator
 * @export
 */
export const StorageCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageCredential: async (createStorageCredential?: CreateStorageCredential, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storageCredentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStorageCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredential: async (storageCredentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageCredentialId' is not null or undefined
            assertParamExists('getStorageCredential', 'storageCredentialId', storageCredentialId)
            const localVarPath = `/api/storageCredentials/{storageCredentialId}`
                .replace(`{${"storageCredentialId"}}`, encodeURIComponent(String(storageCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredentials: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storageCredentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageCredential: async (storageCredentialId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageCredentialId' is not null or undefined
            assertParamExists('shareStorageCredential', 'storageCredentialId', storageCredentialId)
            const localVarPath = `/api/storageCredentials/{storageCredentialId}:share`
                .replace(`{${"storageCredentialId"}}`, encodeURIComponent(String(storageCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId 
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageCredentialSecrets: async (storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageCredentialId' is not null or undefined
            assertParamExists('updateStorageCredentialSecrets', 'storageCredentialId', storageCredentialId)
            const localVarPath = `/api/storageCredentials/{storageCredentialId}:updateSecrets`
                .replace(`{${"storageCredentialId"}}`, encodeURIComponent(String(storageCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStorageCredentialSecrets, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageCredentialsApi - functional programming interface
 * @export
 */
export const StorageCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorageCredential(createStorageCredential?: CreateStorageCredential, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorageCredential(createStorageCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageCredential(storageCredentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageCredentials(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageCredentialList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageCredentials(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareStorageCredential(storageCredentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId 
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageCredentialsApi - factory interface
 * @export
 */
export const StorageCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new storage credential
         * @param {CreateStorageCredential} [createStorageCredential] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageCredential(createStorageCredential?: CreateStorageCredential, options?: any): AxiosPromise<StorageCredential> {
            return localVarFp.createStorageCredential(createStorageCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a storage credential.
         * @param {string} storageCredentialId The ID of the storage credential to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredential(storageCredentialId: string, options?: any): AxiosPromise<StorageCredential> {
            return localVarFp.getStorageCredential(storageCredentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of storage credentials.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageCredentials(options?: any): AxiosPromise<StorageCredentialList> {
            return localVarFp.getStorageCredentials(options).then((request) => request(axios, basePath));
        },
        /**
         * Here you share your own storage credentials with all the other users in your tenant.
         * @summary Share your own storage credentials with tenant.
         * @param {string} storageCredentialId The ID of the storage credential to share
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareStorageCredential(storageCredentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.shareStorageCredential(storageCredentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * When your storage credentials change or get updated due to security reasons you need to update them here.
         * @summary Update a storage credential\'s secrets.
         * @param {string} storageCredentialId 
         * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets, options?: any): AxiosPromise<void> {
            return localVarFp.updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageCredentialsApi - object-oriented interface
 * @export
 * @class StorageCredentialsApi
 * @extends {BaseAPI}
 */
export class StorageCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new storage credential
     * @param {CreateStorageCredential} [createStorageCredential] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    public createStorageCredential(createStorageCredential?: CreateStorageCredential, options?: AxiosRequestConfig) {
        return StorageCredentialsApiFp(this.configuration).createStorageCredential(createStorageCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a storage credential.
     * @param {string} storageCredentialId The ID of the storage credential to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    public getStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig) {
        return StorageCredentialsApiFp(this.configuration).getStorageCredential(storageCredentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of storage credentials.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    public getStorageCredentials(options?: AxiosRequestConfig) {
        return StorageCredentialsApiFp(this.configuration).getStorageCredentials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Here you share your own storage credentials with all the other users in your tenant.
     * @summary Share your own storage credentials with tenant.
     * @param {string} storageCredentialId The ID of the storage credential to share
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    public shareStorageCredential(storageCredentialId: string, options?: AxiosRequestConfig) {
        return StorageCredentialsApiFp(this.configuration).shareStorageCredential(storageCredentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When your storage credentials change or get updated due to security reasons you need to update them here.
     * @summary Update a storage credential\'s secrets.
     * @param {string} storageCredentialId 
     * @param {UpdateStorageCredentialSecrets} [updateStorageCredentialSecrets] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageCredentialsApi
     */
    public updateStorageCredentialSecrets(storageCredentialId: string, updateStorageCredentialSecrets?: UpdateStorageCredentialSecrets, options?: AxiosRequestConfig) {
        return StorageCredentialsApiFp(this.configuration).updateStorageCredentialSecrets(storageCredentialId, updateStorageCredentialSecrets, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJwtToken: async (tenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication PsTokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshJwtToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tokens:refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJwtToken(tenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJwtToken(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshJwtToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshJwtToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
         * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
         * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJwtToken(tenant?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.createJwtToken(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * When still having a valid JWT, this endpoint can be used to extend the validity.
         * @summary Refresh a JWT using a not yet expired, still valid JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshJwtToken(options?: any): AxiosPromise<Token> {
            return localVarFp.refreshJwtToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Generate a JWT using an API-key, Basic Authentication or a psToken. When using Basic Authentication, and you are member of several tenants, also provide the tenant request parameter to indicate for which tenant you want to authenticate. Note that Basic Authentication will not work for SSO (Single Sign On) enabled authentication.
     * @summary Generate a JWT using an API-key, Basic Authentication or a psToken.
     * @param {string} [tenant] The name of your tenant in case you have access to multiple tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public createJwtToken(tenant?: string, options?: AxiosRequestConfig) {
        return TokenApiFp(this.configuration).createJwtToken(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When still having a valid JWT, this endpoint can be used to extend the validity.
     * @summary Refresh a JWT using a not yet expired, still valid JWT.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public refreshJwtToken(options?: AxiosRequestConfig) {
        return TokenApiFp(this.configuration).refreshJwtToken(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('approveUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}:approve`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTenantAdminRightsToUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignTenantAdminRightsToUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}:assignTenantAdministratorRights`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeTenantAdminRightsToUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('revokeTenantAdminRightsToUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}:revokeTenantAdministratorRights`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, ifMatch?: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ifMatch !== undefined && ifMatch !== null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.illumina.v3+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTenantAdminRightsToUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeTenantAdminRightsToUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, ifMatch?: string, user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, ifMatch, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Approve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Assign tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTenantAdminRightsToUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.assignTenantAdminRightsToUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<UserList> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
         * @summary Revoke tenant administrator rights to a user.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeTenantAdminRightsToUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeTenantAdminRightsToUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
         * @summary Update a user.
         * @param {string} userId 
         * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, ifMatch?: string, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userId, ifMatch, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Endpoint for approving a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Approve a user.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public approveUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).approveUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for assigning tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Assign tenant administrator rights to a user.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public assignTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).assignTenantAdminRightsToUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for revoking tenant administrator rights to a user.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.
     * @summary Revoke tenant administrator rights to a user.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeTenantAdminRightsToUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).revokeTenantAdminRightsToUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fields which can be updated: - greeting - two factor authentication - job title - first name - last name - mobile phone number - phone number - fax number - address lines - postal code - city - country - state
     * @summary Update a user.
     * @param {string} userId 
     * @param {string} [ifMatch] Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client\&#39;s most recent value of the \&#39;ETag\&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, ifMatch?: string, user?: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, ifMatch, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkgroupApi - axios parameter creator
 * @export
 */
export const WorkgroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup: async (workgroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workgroupId' is not null or undefined
            assertParamExists('getWorkgroup', 'workgroupId', workgroupId)
            const localVarPath = `/api/workgroups/{workgroupId}`
                .replace(`{${"workgroupId"}}`, encodeURIComponent(String(workgroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            // authentication JwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkgroupApi - functional programming interface
 * @export
 */
export const WorkgroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkgroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkgroup(workgroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workgroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkgroup(workgroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkgroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkgroupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkgroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkgroupApi - factory interface
 * @export
 */
export const WorkgroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkgroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a workgroup.
         * @param {string} workgroupId The ID of the workgroup to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroup(workgroupId: string, options?: any): AxiosPromise<Workgroup> {
            return localVarFp.getWorkgroup(workgroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of workgroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkgroups(options?: any): AxiosPromise<WorkgroupList> {
            return localVarFp.getWorkgroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkgroupApi - object-oriented interface
 * @export
 * @class WorkgroupApi
 * @extends {BaseAPI}
 */
export class WorkgroupApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a workgroup.
     * @param {string} workgroupId The ID of the workgroup to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    public getWorkgroup(workgroupId: string, options?: AxiosRequestConfig) {
        return WorkgroupApiFp(this.configuration).getWorkgroup(workgroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of workgroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkgroupApi
     */
    public getWorkgroups(options?: AxiosRequestConfig) {
        return WorkgroupApiFp(this.configuration).getWorkgroups(options).then((request) => request(this.axios, this.basePath));
    }
}


